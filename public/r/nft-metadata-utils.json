{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "nft-metadata-utils",
  "type": "registry:lib",
  "title": "nftMetadataUtils",
  "description": "NFT metadata utilities with support for multiple standards including Manifold, Thirdweb, ERC721, and ERC1155",
  "dependencies": [
    "viem"
  ],
  "registryDependencies": [
    "https://hellno-mini-app-ui.vercel.app/r/nft-standards.json"
  ],
  "files": [
    {
      "path": "registry/mini-app/lib/nft-metadata-utils.ts",
      "content": "import { type Address, type PublicClient, getAddress } from \"viem\";\nimport { \n  MANIFOLD_DETECTION_ABI, \n  MANIFOLD_EXTENSION_ABI, \n  KNOWN_CONTRACTS, \n  ERC721_ABI,\n  ERC1155_ABI,\n  THIRDWEB_OPENEDITONERC721_ABI\n} from \"@/registry/mini-app/lib/nft-standards\";\n\n/**\n * NFT metadata utilities with support for multiple standards and fallback mechanisms\n */\n\nexport type ProviderHint = \"manifold\" | \"thirdweb\" | \"standard\" | \"erc1155\";\n\nexport interface ManifoldDetectionResult {\n  isManifold: boolean;\n  extensionAddress?: Address;\n  extensions?: Address[];\n}\n\nexport interface ManifoldClaim {\n  total: number;\n  totalMax: number;\n  walletMax: number;\n  startDate: bigint;\n  endDate: bigint;\n  storageProtocol: number;\n  merkleRoot: `0x${string}`;\n  location: string;\n  tokenId: bigint;\n  cost: bigint;\n  paymentReceiver: Address;\n  erc20: Address;\n  signingAddress: Address;\n}\n\n/**\n * Detect if a contract is a Manifold contract with extensions\n */\nexport async function detectManifoldContract(\n  client: PublicClient,\n  contractAddress: Address\n): Promise<ManifoldDetectionResult> {\n  try {\n    const extensions = await client.readContract({\n      address: getAddress(contractAddress),\n      abi: MANIFOLD_DETECTION_ABI,\n      functionName: \"getExtensions\",\n    }) as Address[];\n    \n    if (!extensions || extensions.length === 0) {\n      return { isManifold: false };\n    }\n    \n    // Check if it has the known Manifold extension\n    const knownExtension = extensions.find(\n      ext => ext.toLowerCase() === KNOWN_CONTRACTS.manifoldExtension.toLowerCase()\n    );\n    \n    return {\n      isManifold: true,\n      extensionAddress: knownExtension || extensions[0],\n      extensions,\n    };\n  } catch {\n    return { isManifold: false };\n  }\n}\n\n/**\n * Get token URI for a Manifold NFT\n */\nexport async function getManifoldTokenURI(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string,\n  extensionAddress?: Address\n): Promise<string> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  return await client.readContract({\n    address: getAddress(extension),\n    abi: MANIFOLD_EXTENSION_ABI,\n    functionName: \"tokenURI\",\n    args: [getAddress(contractAddress), BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get token URI with automatic Manifold detection\n * @deprecated Use getTokenMetadataURL instead for more comprehensive metadata support\n */\nexport async function getTokenURIWithManifoldSupport(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string\n): Promise<string> {\n  // Try Manifold first\n  const manifoldInfo = await detectManifoldContract(client, contractAddress);\n  \n  if (manifoldInfo.isManifold && manifoldInfo.extensionAddress) {\n    try {\n      return await getManifoldTokenURI(\n        client,\n        contractAddress,\n        tokenId,\n        manifoldInfo.extensionAddress\n      );\n    } catch (error) {\n      console.warn(\"Failed to get Manifold tokenURI, falling back to standard\", error);\n    }\n  }\n  \n  // Fallback to standard ERC721 tokenURI\n  return await client.readContract({\n    address: getAddress(contractAddress),\n    abi: ERC721_ABI.tokenURI,\n    functionName: \"tokenURI\",\n    args: [BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get token metadata URL with comprehensive fallback chain\n * Supports multiple NFT standards including ERC721, ERC1155, Manifold, and Thirdweb OpenEditions\n * \n * @param client - Public client for blockchain interactions\n * @param contractAddress - NFT contract address\n * @param tokenId - Token ID to fetch metadata for\n * @param providerHint - Optional hint about the contract type for optimization\n * @returns Token metadata URL or empty string if not found\n */\nexport async function getTokenMetadataURL(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string,\n  providerHint?: ProviderHint\n): Promise<string> {\n  const address = getAddress(contractAddress);\n  const tokenIdBigInt = BigInt(tokenId);\n  \n  // If provider hint is given, try that first\n  if (providerHint) {\n    try {\n      switch (providerHint) {\n        case \"manifold\": {\n          const manifoldInfo = await detectManifoldContract(client, address);\n          if (manifoldInfo.isManifold && manifoldInfo.extensionAddress) {\n            return await getManifoldTokenURI(client, address, tokenId, manifoldInfo.extensionAddress);\n          }\n          break;\n        }\n        case \"erc1155\": {\n          const uri = await client.readContract({\n            address,\n            abi: ERC1155_ABI.uri,\n            functionName: \"uri\",\n            args: [tokenIdBigInt],\n          }) as string;\n          // ERC1155 URIs often have {id} placeholder that needs to be replaced\n          return uri.replace(\"{id}\", tokenId.padStart(64, \"0\"));\n        }\n        case \"thirdweb\": {\n          // Try sharedMetadata first for OpenEditions\n          const metadata = await client.readContract({\n            address,\n            abi: THIRDWEB_OPENEDITONERC721_ABI,\n            functionName: \"sharedMetadata\",\n          }) as any;\n          if (metadata && metadata.image) {\n            // Construct metadata JSON from sharedMetadata\n            const metadataJson = {\n              name: metadata.name || \"\",\n              description: metadata.description || \"\",\n              image: metadata.image,\n              animation_url: metadata.animationUrl || undefined,\n            };\n            // Return as data URI\n            return `data:application/json;base64,${btoa(JSON.stringify(metadataJson))}`;\n          }\n          break;\n        }\n      }\n    } catch (error) {\n      console.debug(`Provider hint ${providerHint} failed, trying other methods`, error);\n    }\n  }\n  \n  // Comprehensive fallback chain\n  const fallbackMethods = [\n    // 1. Standard ERC721 tokenURI\n    async () => {\n      return await client.readContract({\n        address,\n        abi: ERC721_ABI.tokenURI,\n        functionName: \"tokenURI\",\n        args: [tokenIdBigInt],\n      }) as string;\n    },\n    \n    // 2. ERC1155 uri\n    async () => {\n      const uri = await client.readContract({\n        address,\n        abi: ERC1155_ABI.uri,\n        functionName: \"uri\",\n        args: [tokenIdBigInt],\n      }) as string;\n      // Replace {id} placeholder if present\n      return uri.replace(\"{id}\", tokenId.padStart(64, \"0\"));\n    },\n    \n    // 3. Manifold detection and tokenURI\n    async () => {\n      const manifoldInfo = await detectManifoldContract(client, address);\n      if (manifoldInfo.isManifold && manifoldInfo.extensionAddress) {\n        return await getManifoldTokenURI(client, address, tokenId, manifoldInfo.extensionAddress);\n      }\n      throw new Error(\"Not a Manifold contract\");\n    },\n    \n    // 4. contractURI (for contracts with shared metadata)\n    async () => {\n      const contractURI = await client.readContract({\n        address,\n        abi: ERC721_ABI.contractURI,\n        functionName: \"contractURI\",\n      }) as string;\n      // Note: contractURI typically contains collection-level metadata, not token-specific\n      // This is a last resort fallback\n      return contractURI;\n    },\n    \n    // 5. Thirdweb sharedMetadata (for OpenEditions)\n    async () => {\n      const metadata = await client.readContract({\n        address,\n        abi: THIRDWEB_OPENEDITONERC721_ABI,\n        functionName: \"sharedMetadata\",\n      }) as any;\n      \n      if (metadata && metadata.image) {\n        // Construct metadata JSON from sharedMetadata\n        const metadataJson = {\n          name: metadata.name || `Token #${tokenId}`,\n          description: metadata.description || \"\",\n          image: metadata.image,\n          animation_url: metadata.animationUrl || undefined,\n        };\n        // Return as data URI\n        return `data:application/json;base64,${btoa(JSON.stringify(metadataJson))}`;\n      }\n      throw new Error(\"No shared metadata found\");\n    },\n    \n    // 6. baseURI + tokenId concatenation\n    async () => {\n      const baseURI = await client.readContract({\n        address,\n        abi: ERC721_ABI.baseURI,\n        functionName: \"baseURI\",\n      }) as string;\n      \n      if (baseURI) {\n        // Ensure proper URL joining\n        const separator = baseURI.endsWith(\"/\") ? \"\" : \"/\";\n        return `${baseURI}${separator}${tokenId}`;\n      }\n      throw new Error(\"No baseURI found\");\n    },\n  ];\n  \n  // Try each method in order\n  for (const method of fallbackMethods) {\n    try {\n      const result = await method();\n      if (result && typeof result === \"string\" && result.length > 0) {\n        return result;\n      }\n    } catch (error) {\n      // Continue to next method\n      continue;\n    }\n  }\n  \n  // If all methods fail, return empty string\n  console.warn(`Could not fetch metadata for token ${tokenId} at ${contractAddress}`);\n  return \"\";\n}\n\n/**\n * Get Manifold claim information\n */\nexport async function getManifoldClaim(\n  client: PublicClient,\n  contractAddress: Address,\n  instanceId: string,\n  extensionAddress?: Address\n): Promise<ManifoldClaim | null> {\n  try {\n    const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n    \n    const claim = await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"getClaim\",\n      args: [getAddress(contractAddress), BigInt(instanceId)],\n    });\n    \n    return claim as unknown as ManifoldClaim;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get Manifold mint fee\n */\nexport async function getManifoldMintFee(\n  client: PublicClient,\n  extensionAddress?: Address\n): Promise<bigint> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  try {\n    return await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"MINT_FEE\",\n    }) as bigint;\n  } catch {\n    // Try MINT_FEE_MERKLE as fallback\n    try {\n      return await client.readContract({\n        address: getAddress(extension),\n        abi: MANIFOLD_EXTENSION_ABI,\n        functionName: \"MINT_FEE_MERKLE\",\n      }) as bigint;\n    } catch {\n      return BigInt(0);\n    }\n  }\n}\n\n/**\n * Check if an address is the zero address\n */\nexport function isZeroAddress(address: string): boolean {\n  return address === \"0x0000000000000000000000000000000000000000\";\n}\n\n/**\n * Format instance ID and token ID for display\n */\nexport function formatManifoldTokenId(instanceId: string, tokenId: string): string {\n  return `${instanceId}-${tokenId}`;\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/lib/nft-standards.ts",
      "content": "import { parseAbi, type Address } from \"viem\";\n\n/**\n * Common NFT contract ABIs and standards\n */\n\n// Standard ERC721 functions\nexport const ERC721_ABI = {\n  full: parseAbi([\n    \"function tokenURI(uint256 tokenId) view returns (string)\",\n    \"function name() view returns (string)\",\n    \"function symbol() view returns (string)\",\n    \"function ownerOf(uint256 tokenId) view returns (address)\",\n    \"function balanceOf(address owner) view returns (uint256)\",\n    \"function totalSupply() view returns (uint256)\",\n    \"function baseURI() view returns (string)\",\n    \"function contractURI() view returns (string)\",\n  ]),\n  \n  // Individual functions for specific use cases\n  tokenURI: parseAbi([\"function tokenURI(uint256 tokenId) view returns (string)\"]),\n  name: parseAbi([\"function name() view returns (string)\"]),\n  symbol: parseAbi([\"function symbol() view returns (string)\"]),\n  ownerOf: parseAbi([\"function ownerOf(uint256 tokenId) view returns (address)\"]),\n  baseURI: parseAbi([\"function baseURI() view returns (string)\"]),\n  contractURI: parseAbi([\"function contractURI() view returns (string)\"]),\n};\n\n// Common price discovery functions across NFT contracts\nexport const PRICE_DISCOVERY_ABI = parseAbi([\n  \"function mintPrice() view returns (uint256)\",\n  \"function price() view returns (uint256)\",\n  \"function MINT_PRICE() view returns (uint256)\",\n  \"function getMintPrice() view returns (uint256)\",\n  \"function publicMintPrice() view returns (uint256)\",\n]);\n\n// Common mint functions\nexport const MINT_ABI = parseAbi([\n  \"function mint(uint256 amount) payable\",\n  \"function mint(address to, uint256 amount) payable\",\n  \"function publicMint(uint256 amount) payable\",\n  \"function mintTo(address to, uint256 amount) payable\",\n]);\n\n// ERC1155 metadata function\nexport const ERC1155_ABI = {\n  uri: parseAbi([\"function uri(uint256 tokenId) view returns (string)\"]),\n};\n\n// ERC20 ABI for token interactions\nexport const ERC20_ABI = parseAbi([\n  \"function decimals() view returns (uint8)\",\n  \"function symbol() view returns (string)\",\n  \"function name() view returns (string)\",\n  \"function totalSupply() view returns (uint256)\",\n  \"function balanceOf(address owner) view returns (uint256)\",\n  \"function allowance(address owner, address spender) view returns (uint256)\",\n  \"function approve(address spender, uint256 value) returns (bool)\",\n  \"function transfer(address to, uint256 value) returns (bool)\",\n  \"function transferFrom(address from, address to, uint256 value) returns (bool)\",\n]);\n\n// Manifold contract detection ABI (kept separate as it's used on the main contract)\nexport const MANIFOLD_DETECTION_ABI = parseAbi([\n  \"function getExtensions() view returns (address[])\",\n]);\n\n// Manifold extension contract full ABI\nexport const MANIFOLD_EXTENSION_ABI = [\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"tokenURI\",\n    outputs: [{ name: \"uri\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" }\n    ],\n    name: \"getClaim\",\n    outputs: [\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"tokenId\", type: \"uint256\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"getClaimForToken\",\n    outputs: [\n      { name: \"instanceId\", type: \"uint256\" },\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"tokenId\", type: \"uint256\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" },\n      { name: \"mintIndex\", type: \"uint32\" },\n      { name: \"merkleProof\", type: \"bytes32[]\" },\n      { name: \"mintFor\", type: \"address\" }\n    ],\n    name: \"mint\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE_MERKLE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n] as const;\n\n// ERC165 interface detection\nexport const ERC165_ABI = parseAbi([\n  \"function supportsInterface(bytes4 interfaceId) view returns (bool)\",\n]);\n\n// Known contract addresses\nexport const KNOWN_CONTRACTS = {\n  // Manifold extension contracts\n  manifoldExtension: \"0x26BBEA7803DcAc346D5F5f135b57Cf2c752A02bE\" as Address,\n  \n  // Add other known contracts here as needed\n} as const;\n\n// thirdweb OpenEditionERC721 ABI\nexport const THIRDWEB_OPENEDITONERC721_ABI = [\n  {\n    inputs: [\n      { name: \"_receiver\", type: \"address\" },\n      { name: \"_quantity\", type: \"uint256\" },\n      { name: \"_currency\", type: \"address\" },\n      { name: \"_pricePerToken\", type: \"uint256\" },\n      {\n        components: [\n          { name: \"proof\", type: \"bytes32[]\" },\n          { name: \"quantityLimitPerWallet\", type: \"uint256\" },\n          { name: \"pricePerToken\", type: \"uint256\" },\n          { name: \"currency\", type: \"address\" }\n        ],\n        name: \"_allowlistProof\",\n        type: \"tuple\"\n      },\n      { name: \"_data\", type: \"bytes\" }\n    ],\n    name: \"claim\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"claimCondition\",\n    outputs: [\n      { name: \"currentStartId\", type: \"uint256\" },\n      { name: \"count\", type: \"uint256\" }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ name: \"_conditionId\", type: \"uint256\" }],\n    name: \"getClaimConditionById\",\n    outputs: [\n      {\n        components: [\n          { name: \"startTimestamp\", type: \"uint256\" },\n          { name: \"maxClaimableSupply\", type: \"uint256\" },\n          { name: \"supplyClaimed\", type: \"uint256\" },\n          { name: \"quantityLimitPerWallet\", type: \"uint256\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"pricePerToken\", type: \"uint256\" },\n          { name: \"currency\", type: \"address\" },\n          { name: \"metadata\", type: \"string\" }\n        ],\n        name: \"condition\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"sharedMetadata\",\n    outputs: [\n      { name: \"name\", type: \"string\" },\n      { name: \"description\", type: \"string\" },\n      { name: \"image\", type: \"string\" },\n      { name: \"animationUrl\", type: \"string\" }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n] as const;\n\n// Native ETH address for thirdweb contracts\nexport const THIRDWEB_NATIVE_TOKEN = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" as Address;\n\n// Interface IDs for contract detection\nexport const INTERFACE_IDS = {\n  ERC165: \"0x01ffc9a7\",\n  ERC721: \"0x80ac58cd\",\n  ERC1155: \"0xd9b67a26\",\n  ERC721Metadata: \"0x5b5e139f\",\n} as const;\n\n// IPFS Gateway configuration\nexport const IPFS_GATEWAYS = {\n  default: \"https://ipfs.io/ipfs/\",\n  cloudflare: \"https://cloudflare-ipfs.com/ipfs/\",\n  pinata: \"https://gateway.pinata.cloud/ipfs/\",\n} as const;\n\n/**\n * Convert IPFS URL to HTTP gateway URL\n */\nexport function ipfsToHttp(url: string, gateway?: keyof typeof IPFS_GATEWAYS): string {\n  const selectedGateway = gateway || \"default\";\n  if (!url || !url.startsWith(\"ipfs://\")) {\n    return url;\n  }\n  \n  return url.replace(\"ipfs://\", IPFS_GATEWAYS[selectedGateway]);\n}\n\n/**\n * Check if a contract is likely an NFT contract by checking interface support\n */\nexport async function isNFTContract(\n  client: any,\n  contractAddress: Address\n): Promise<{ isNFT: boolean; type?: 'ERC721' | 'ERC1155' }> {\n  try {\n    // Try ERC165 supportsInterface\n    const [supportsERC721, supportsERC1155] = await Promise.all([\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC721],\n      }).catch(() => false),\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC1155],\n      }).catch(() => false),\n    ]);\n    \n    if (supportsERC721) return { isNFT: true, type: 'ERC721' };\n    if (supportsERC1155) return { isNFT: true, type: 'ERC1155' };\n    \n    // Fallback: try to call name() function\n    const name = await client.readContract({\n      address: contractAddress,\n      abi: ERC721_ABI.name,\n      functionName: 'name',\n    }).catch(() => null);\n    \n    return { isNFT: !!name };\n  } catch {\n    return { isNFT: false };\n  }\n}",
      "type": "registry:lib",
      "target": ""
    }
  ]
}