{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "manifold-utils",
  "type": "registry:lib",
  "title": "manifoldUtils",
  "description": "Manifold contract detection and token URI utilities",
  "dependencies": [
    "viem"
  ],
  "registryDependencies": [
    "https://hellno-mini-app-ui.vercel.app/r/nft-standards.json"
  ],
  "files": [
    {
      "path": "registry/mini-app/lib/manifold-utils.ts",
      "content": "import { type Address, type PublicClient, getAddress } from \"viem\";\nimport { MANIFOLD_DETECTION_ABI, MANIFOLD_EXTENSION_ABI, KNOWN_CONTRACTS, ERC721_ABI } from \"@/registry/mini-app/lib/nft-standards\";\n\n/**\n * Manifold contract utilities\n */\n\nexport interface ManifoldDetectionResult {\n  isManifold: boolean;\n  extensionAddress?: Address;\n  extensions?: Address[];\n}\n\nexport interface ManifoldClaim {\n  total: number;\n  totalMax: number;\n  walletMax: number;\n  startDate: bigint;\n  endDate: bigint;\n  storageProtocol: number;\n  merkleRoot: `0x${string}`;\n  location: string;\n  tokenId: bigint;\n  cost: bigint;\n  paymentReceiver: Address;\n  erc20: Address;\n  signingAddress: Address;\n}\n\n/**\n * Detect if a contract is a Manifold contract with extensions\n */\nexport async function detectManifoldContract(\n  client: PublicClient,\n  contractAddress: Address\n): Promise<ManifoldDetectionResult> {\n  try {\n    const extensions = await client.readContract({\n      address: getAddress(contractAddress),\n      abi: MANIFOLD_DETECTION_ABI,\n      functionName: \"getExtensions\",\n    }) as Address[];\n    \n    if (!extensions || extensions.length === 0) {\n      return { isManifold: false };\n    }\n    \n    // Check if it has the known Manifold extension\n    const knownExtension = extensions.find(\n      ext => ext.toLowerCase() === KNOWN_CONTRACTS.manifoldExtension.toLowerCase()\n    );\n    \n    return {\n      isManifold: true,\n      extensionAddress: knownExtension || extensions[0],\n      extensions,\n    };\n  } catch {\n    return { isManifold: false };\n  }\n}\n\n/**\n * Get token URI for a Manifold NFT\n */\nexport async function getManifoldTokenURI(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string,\n  extensionAddress?: Address\n): Promise<string> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  return await client.readContract({\n    address: getAddress(extension),\n    abi: MANIFOLD_EXTENSION_ABI,\n    functionName: \"tokenURI\",\n    args: [getAddress(contractAddress), BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get token URI with automatic Manifold detection\n */\nexport async function getTokenURIWithManifoldSupport(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string\n): Promise<string> {\n  // Try Manifold first\n  const manifoldInfo = await detectManifoldContract(client, contractAddress);\n  \n  if (manifoldInfo.isManifold && manifoldInfo.extensionAddress) {\n    try {\n      return await getManifoldTokenURI(\n        client,\n        contractAddress,\n        tokenId,\n        manifoldInfo.extensionAddress\n      );\n    } catch (error) {\n      console.warn(\"Failed to get Manifold tokenURI, falling back to standard\", error);\n    }\n  }\n  \n  // Fallback to standard ERC721 tokenURI\n  return await client.readContract({\n    address: getAddress(contractAddress),\n    abi: ERC721_ABI.tokenURI,\n    functionName: \"tokenURI\",\n    args: [BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get Manifold claim information\n */\nexport async function getManifoldClaim(\n  client: PublicClient,\n  contractAddress: Address,\n  instanceId: string,\n  extensionAddress?: Address\n): Promise<ManifoldClaim | null> {\n  try {\n    const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n    \n    const claim = await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"getClaim\",\n      args: [getAddress(contractAddress), BigInt(instanceId)],\n    });\n    \n    return claim as unknown as ManifoldClaim;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get Manifold mint fee\n */\nexport async function getManifoldMintFee(\n  client: PublicClient,\n  extensionAddress?: Address\n): Promise<bigint> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  try {\n    return await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"MINT_FEE\",\n    }) as bigint;\n  } catch {\n    // Try MINT_FEE_MERKLE as fallback\n    try {\n      return await client.readContract({\n        address: getAddress(extension),\n        abi: MANIFOLD_EXTENSION_ABI,\n        functionName: \"MINT_FEE_MERKLE\",\n      }) as bigint;\n    } catch {\n      return BigInt(0);\n    }\n  }\n}\n\n/**\n * Check if an address is the zero address\n */\nexport function isZeroAddress(address: string): boolean {\n  return address === \"0x0000000000000000000000000000000000000000\";\n}\n\n/**\n * Format instance ID and token ID for display\n */\nexport function formatManifoldTokenId(instanceId: string, tokenId: string): string {\n  return `${instanceId}-${tokenId}`;\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/lib/nft-standards.ts",
      "content": "import { parseAbi, type Address } from \"viem\";\n\n/**\n * Common NFT contract ABIs and standards\n */\n\n// Standard ERC721 functions\nexport const ERC721_ABI = {\n  full: parseAbi([\n    \"function tokenURI(uint256 tokenId) view returns (string)\",\n    \"function name() view returns (string)\",\n    \"function symbol() view returns (string)\",\n    \"function ownerOf(uint256 tokenId) view returns (address)\",\n    \"function balanceOf(address owner) view returns (uint256)\",\n    \"function totalSupply() view returns (uint256)\",\n  ]),\n  \n  // Individual functions for specific use cases\n  tokenURI: parseAbi([\"function tokenURI(uint256 tokenId) view returns (string)\"]),\n  name: parseAbi([\"function name() view returns (string)\"]),\n  symbol: parseAbi([\"function symbol() view returns (string)\"]),\n  ownerOf: parseAbi([\"function ownerOf(uint256 tokenId) view returns (address)\"]),\n};\n\n// Common price discovery functions across NFT contracts\nexport const PRICE_DISCOVERY_ABI = parseAbi([\n  \"function mintPrice() view returns (uint256)\",\n  \"function price() view returns (uint256)\",\n  \"function MINT_PRICE() view returns (uint256)\",\n  \"function getMintPrice() view returns (uint256)\",\n  \"function publicMintPrice() view returns (uint256)\",\n]);\n\n// Common mint functions\nexport const MINT_ABI = parseAbi([\n  \"function mint(uint256 amount) payable\",\n  \"function mint(address to, uint256 amount) payable\",\n  \"function publicMint(uint256 amount) payable\",\n  \"function mintTo(address to, uint256 amount) payable\",\n]);\n\n// ERC20 ABI for token interactions\nexport const ERC20_ABI = parseAbi([\n  \"function decimals() view returns (uint8)\",\n  \"function symbol() view returns (string)\",\n  \"function name() view returns (string)\",\n  \"function totalSupply() view returns (uint256)\",\n  \"function balanceOf(address owner) view returns (uint256)\",\n  \"function allowance(address owner, address spender) view returns (uint256)\",\n  \"function approve(address spender, uint256 value) returns (bool)\",\n  \"function transfer(address to, uint256 value) returns (bool)\",\n  \"function transferFrom(address from, address to, uint256 value) returns (bool)\",\n]);\n\n// Manifold contract detection ABI (kept separate as it's used on the main contract)\nexport const MANIFOLD_DETECTION_ABI = parseAbi([\n  \"function getExtensions() view returns (address[])\",\n]);\n\n// Manifold extension contract full ABI\nexport const MANIFOLD_EXTENSION_ABI = [\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"tokenURI\",\n    outputs: [{ name: \"uri\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" }\n    ],\n    name: \"getClaim\",\n    outputs: [\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"tokenId\", type: \"uint256\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"getClaimForToken\",\n    outputs: [\n      { name: \"instanceId\", type: \"uint256\" },\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"tokenId\", type: \"uint256\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" },\n      { name: \"mintIndex\", type: \"uint32\" },\n      { name: \"merkleProof\", type: \"bytes32[]\" },\n      { name: \"mintFor\", type: \"address\" }\n    ],\n    name: \"mint\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE_MERKLE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n] as const;\n\n// ERC165 interface detection\nexport const ERC165_ABI = parseAbi([\n  \"function supportsInterface(bytes4 interfaceId) view returns (bool)\",\n]);\n\n// Known contract addresses\nexport const KNOWN_CONTRACTS = {\n  // Manifold extension contracts\n  manifoldExtension: \"0x26BBEA7803DcAc346D5F5f135b57Cf2c752A02bE\" as Address,\n  \n  // Add other known contracts here as needed\n} as const;\n\n// Interface IDs for contract detection\nexport const INTERFACE_IDS = {\n  ERC165: \"0x01ffc9a7\",\n  ERC721: \"0x80ac58cd\",\n  ERC1155: \"0xd9b67a26\",\n  ERC721Metadata: \"0x5b5e139f\",\n} as const;\n\n// IPFS Gateway configuration\nexport const IPFS_GATEWAYS = {\n  default: \"https://ipfs.io/ipfs/\",\n  cloudflare: \"https://cloudflare-ipfs.com/ipfs/\",\n  pinata: \"https://gateway.pinata.cloud/ipfs/\",\n} as const;\n\n/**\n * Convert IPFS URL to HTTP gateway URL\n */\nexport function ipfsToHttp(url: string, gateway: keyof typeof IPFS_GATEWAYS = 'default'): string {\n  if (!url || !url.startsWith('ipfs://')) {\n    return url;\n  }\n  \n  return url.replace('ipfs://', IPFS_GATEWAYS[gateway]);\n}\n\n/**\n * Check if a contract is likely an NFT contract by checking interface support\n */\nexport async function isNFTContract(\n  client: any,\n  contractAddress: Address\n): Promise<{ isNFT: boolean; type?: 'ERC721' | 'ERC1155' }> {\n  try {\n    // Try ERC165 supportsInterface\n    const [supportsERC721, supportsERC1155] = await Promise.all([\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC721],\n      }).catch(() => false),\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC1155],\n      }).catch(() => false),\n    ]);\n    \n    if (supportsERC721) return { isNFT: true, type: 'ERC721' };\n    if (supportsERC1155) return { isNFT: true, type: 'ERC1155' };\n    \n    // Fallback: try to call name() function\n    const name = await client.readContract({\n      address: contractAddress,\n      abi: ERC721_ABI.name,\n      functionName: 'name',\n    }).catch(() => null);\n    \n    return { isNFT: !!name };\n  } catch {\n    return { isNFT: false };\n  }\n}",
      "type": "registry:lib",
      "target": ""
    }
  ]
}