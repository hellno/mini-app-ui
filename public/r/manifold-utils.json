{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "manifold-utils",
  "type": "registry:lib",
  "title": "manifoldUtils",
  "description": "Manifold contract detection and token URI utilities",
  "dependencies": [
    "viem"
  ],
  "registryDependencies": [
    "https://hellno-mini-app-ui.vercel.app/r/nft-standards.json"
  ],
  "files": [
    {
      "path": "registry/mini-app/lib/manifold-utils.ts",
      "content": "import { type Address, type PublicClient, getAddress } from \"viem\";\nimport { MANIFOLD_DETECTION_ABI, MANIFOLD_EXTENSION_ABI, KNOWN_CONTRACTS, ERC721_ABI } from \"./nft-standards\";\n\n/**\n * Manifold contract utilities\n */\n\nexport interface ManifoldDetectionResult {\n  isManifold: boolean;\n  extensionAddress?: Address;\n  extensions?: Address[];\n}\n\nexport interface ManifoldClaim {\n  total: number;\n  totalMax: number;\n  walletMax: number;\n  startDate: bigint;\n  endDate: bigint;\n  storageProtocol: number;\n  merkleRoot: `0x${string}`;\n  location: string;\n  tokenId: bigint;\n  cost: bigint;\n  paymentReceiver: Address;\n  erc20: Address;\n  signingAddress: Address;\n}\n\n/**\n * Detect if a contract is a Manifold contract with extensions\n */\nexport async function detectManifoldContract(\n  client: PublicClient,\n  contractAddress: Address\n): Promise<ManifoldDetectionResult> {\n  try {\n    const extensions = await client.readContract({\n      address: getAddress(contractAddress),\n      abi: MANIFOLD_DETECTION_ABI,\n      functionName: \"getExtensions\",\n    }) as Address[];\n    \n    if (!extensions || extensions.length === 0) {\n      return { isManifold: false };\n    }\n    \n    // Check if it has the known Manifold extension\n    const knownExtension = extensions.find(\n      ext => ext.toLowerCase() === KNOWN_CONTRACTS.manifoldExtension.toLowerCase()\n    );\n    \n    return {\n      isManifold: true,\n      extensionAddress: knownExtension || extensions[0],\n      extensions,\n    };\n  } catch {\n    return { isManifold: false };\n  }\n}\n\n/**\n * Get token URI for a Manifold NFT\n */\nexport async function getManifoldTokenURI(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string,\n  extensionAddress?: Address\n): Promise<string> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  return await client.readContract({\n    address: getAddress(extension),\n    abi: MANIFOLD_EXTENSION_ABI,\n    functionName: \"tokenURI\",\n    args: [getAddress(contractAddress), BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get token URI with automatic Manifold detection\n */\nexport async function getTokenURIWithManifoldSupport(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string\n): Promise<string> {\n  // Try Manifold first\n  const manifoldInfo = await detectManifoldContract(client, contractAddress);\n  \n  if (manifoldInfo.isManifold && manifoldInfo.extensionAddress) {\n    try {\n      return await getManifoldTokenURI(\n        client,\n        contractAddress,\n        tokenId,\n        manifoldInfo.extensionAddress\n      );\n    } catch (error) {\n      console.warn(\"Failed to get Manifold tokenURI, falling back to standard\", error);\n    }\n  }\n  \n  // Fallback to standard ERC721 tokenURI\n  return await client.readContract({\n    address: getAddress(contractAddress),\n    abi: ERC721_ABI.tokenURI,\n    functionName: \"tokenURI\",\n    args: [BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get Manifold claim information\n */\nexport async function getManifoldClaim(\n  client: PublicClient,\n  contractAddress: Address,\n  instanceId: string,\n  extensionAddress?: Address\n): Promise<ManifoldClaim | null> {\n  try {\n    const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n    \n    const claim = await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"getClaim\",\n      args: [getAddress(contractAddress), BigInt(instanceId)],\n    });\n    \n    return claim as unknown as ManifoldClaim;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get Manifold mint fee\n */\nexport async function getManifoldMintFee(\n  client: PublicClient,\n  extensionAddress?: Address\n): Promise<bigint> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  try {\n    return await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"MINT_FEE\",\n    }) as bigint;\n  } catch {\n    // Try MINT_FEE_MERKLE as fallback\n    try {\n      return await client.readContract({\n        address: getAddress(extension),\n        abi: MANIFOLD_EXTENSION_ABI,\n        functionName: \"MINT_FEE_MERKLE\",\n      }) as bigint;\n    } catch {\n      return BigInt(0);\n    }\n  }\n}\n\n/**\n * Check if an address is the zero address\n */\nexport function isZeroAddress(address: string): boolean {\n  return address === \"0x0000000000000000000000000000000000000000\";\n}\n\n/**\n * Format instance ID and token ID for display\n */\nexport function formatManifoldTokenId(instanceId: string, tokenId: string): string {\n  return `${instanceId}-${tokenId}`;\n}",
      "type": "registry:lib"
    }
  ]
}