{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "nft-mint-flow",
  "type": "registry:block",
  "description": "Universal NFT minting component that auto-detects provider (Manifold, OpenSea, generic) and handles all complexity including ERC20 payments and approvals",
  "dependencies": [
    "lucide-react",
    "wagmi",
    "viem",
    "@farcaster/frame-wagmi-connector",
    "@radix-ui/react-slot",
    "class-variance-authority",
    "clsx",
    "tailwind-merge",
    "@farcaster/frame-sdk",
    "@farcaster/frame-core"
  ],
  "devDependencies": [],
  "registryDependencies": [
    "button",
    "sheet",
    "https://hellno-mini-app-ui.vercel.app/r/use-miniapp-sdk.json",
    "https://hellno-mini-app-ui.vercel.app/r/chains.json",
    "https://hellno-mini-app-ui.vercel.app/r/nft-standards.json"
  ],
  "files": [
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/nft-mint-flow.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { Button } from \"@/registry/mini-app/ui/button\";\nimport {\n  Sheet,\n  SheetContent,\n  SheetHeader,\n  SheetTitle,\n} from \"@/registry/mini-app/ui/sheet\";\nimport { useMiniAppSdk } from \"@/registry/mini-app/hooks/use-miniapp-sdk\";\nimport {\n  useAccount,\n  useConnect,\n  useWaitForTransactionReceipt,\n  useWriteContract,\n  useSwitchChain,\n} from \"wagmi\";\nimport { formatEther, type Address } from \"viem\";\nimport { farcasterFrame } from \"@farcaster/frame-wagmi-connector\";\nimport {\n  Coins,\n  CheckCircle,\n  AlertCircle,\n  Loader2,\n  Info,\n  ExternalLink,\n  RefreshCw,\n  Wallet,\n} from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  detectNFTProvider,\n  validateParameters,\n  getClientForChain,\n} from \"./lib/provider-detector\";\nimport { getProviderConfig } from \"./lib/provider-configs\";\nimport { fetchPriceData } from \"./lib/price-optimizer\";\nimport { mintReducer, initialState, type MintStep } from \"./lib/mint-reducer\";\nimport type { MintParams } from \"./lib/types\";\nimport { parseError, type ParsedError } from \"./lib/error-parser\";\n\n/**\n * NFTMintFlow - Universal NFT minting component with automatic provider detection and ERC20 approval handling\n *\n * @example\n * ```tsx\n * // Basic ETH mint (auto-detects provider)\n * <NFTMintFlow\n *   contractAddress=\"0x5b97886E4e1fC0F7d19146DEC03C917994b3c3a4\"\n *   chainId={1}\n * />\n *\n * // Manifold NFT with ERC20 payment (HIGHER token)\n * <NFTMintFlow\n *   contractAddress=\"0x32dd0a7190b5bba94549a0d04659a9258f5b1387\"\n *   chainId={8453}\n *   provider=\"manifold\"\n *   manifoldParams={{ instanceId: \"4293509360\", tokenId: \"2\" }}\n * />\n *\n * // Multiple NFTs with custom button\n * <NFTMintFlow\n *   contractAddress=\"0x...\"\n *   chainId={8453}\n *   amount={5}\n *   buttonText=\"Mint 5 NFTs\"\n *   onMintSuccess={(txHash) => console.log('Minted!', txHash)}\n * />\n * ```\n */\ntype NFTMintFlowProps = {\n  /**\n   * NFT contract address (0x...). This should be the main NFT contract, not the minting contract.\n   * For Manifold, this is the creator contract, not the extension.\n   */\n  contractAddress: Address;\n\n  /**\n   * Blockchain network ID\n   * - 1 = Ethereum mainnet\n   * - 8453 = Base mainnet\n   */\n  chainId: 1 | 8453;\n\n  /**\n   * Optional provider hint. Use when:\n   * - Auto-detection is failing\n   * - You know the provider and want faster loading\n   * - Testing specific provider flows\n   *\n   * Leave undefined for automatic detection.\n   */\n  provider?: \"manifold\" | \"opensea\" | \"zora\" | \"generic\";\n\n  /**\n   * Number of NFTs to mint. Defaults to 1.\n   * Note: For ERC20 payments, the total cost is multiplied by this amount.\n   */\n  amount?: number;\n\n  /**\n   * Manifold-specific parameters. Required when provider=\"manifold\".\n   * - instanceId: The claim instance ID from Manifold (required for most Manifold NFTs)\n   * - tokenId: The specific token ID (required for some editions)\n   *\n   * Find these in the Manifold claim page URL or contract details.\n   */\n  manifoldParams?: {\n    instanceId?: string;\n    tokenId?: string;\n  };\n\n  // UI customization\n  /** Additional CSS classes */\n  className?: string;\n  /** Button style variant */\n  variant?: \"default\" | \"destructive\" | \"secondary\" | \"ghost\" | \"outline\";\n  /** Button size */\n  size?: \"default\" | \"sm\" | \"lg\" | \"icon\";\n  /** Custom button text. Defaults to \"Mint NFT\" */\n  buttonText?: string;\n  /** Disable the mint button */\n  disabled?: boolean;\n\n  /**\n   * Called when NFT minting succeeds (not on approval success)\n   * @param txHash - The mint transaction hash (not approval tx)\n   */\n  onMintSuccess?: (txHash: string) => void;\n\n  /**\n   * Called when NFT minting fails (not on approval failure)\n   * @param error - Human-readable error message\n   */\n  onMintError?: (error: string) => void;\n};\n\nexport function NFTMintFlow({\n  contractAddress,\n  chainId,\n  provider,\n  amount = 1,\n  manifoldParams,\n  className,\n  variant = \"default\",\n  size = \"default\",\n  buttonText = \"Mint NFT\",\n  disabled = false,\n  onMintSuccess,\n  onMintError,\n}: NFTMintFlowProps) {\n  const [state, dispatch] = React.useReducer(mintReducer, initialState);\n  const [isSheetOpen, setIsSheetOpen] = React.useState(false);\n  const [parsedError, setParsedError] = React.useState<ParsedError | null>(null);\n\n  // Prop validation with helpful errors\n  React.useEffect(() => {\n    if (\n      provider === \"manifold\" &&\n      !manifoldParams?.instanceId &&\n      !manifoldParams?.tokenId\n    ) {\n      console.error(\n        \"NFTMintFlow: When provider='manifold', you must provide manifoldParams with either instanceId or tokenId. \" +\n          \"Example: manifoldParams={{ instanceId: '4293509360' }}\",\n      );\n    }\n\n    if (manifoldParams && provider !== \"manifold\") {\n      console.warn(\n        \"NFTMintFlow: manifoldParams provided but provider is not 'manifold'. \" +\n          \"Did you forget to set provider='manifold'?\",\n      );\n    }\n\n    if (chainId !== 1 && chainId !== 8453) {\n      console.warn(\n        `NFTMintFlow: Chain ID ${chainId} may not be supported. ` +\n          \"Currently tested chains: 1 (Ethereum), 8453 (Base)\",\n      );\n    }\n\n    if (!contractAddress || !contractAddress.match(/^0x[a-fA-F0-9]{40}$/)) {\n      console.error(\n        \"NFTMintFlow: Invalid contract address. Must be a valid Ethereum address (0x...)\",\n      );\n    }\n  }, [provider, manifoldParams, chainId, contractAddress]);\n\n  // Destructure commonly used values\n  const {\n    step,\n    contractInfo,\n    priceData,\n    error,\n    txHash,\n    txType,\n    isLoading,\n    validationErrors,\n  } = state;\n  const { erc20Details } = priceData;\n\n  const { isSDKLoaded } = useMiniAppSdk();\n  const { isConnected, address, chain } = useAccount();\n  const { connect } = useConnect();\n  const { switchChain } = useSwitchChain();\n  const {\n    writeContract,\n    isPending: isWritePending,\n    data: writeData,\n    error: writeError,\n  } = useWriteContract();\n\n  // Build mint params\n  const mintParams: MintParams = React.useMemo(\n    () => ({\n      contractAddress,\n      chainId,\n      provider,\n      amount,\n      instanceId: manifoldParams?.instanceId,\n      tokenId: manifoldParams?.tokenId,\n      recipient: address,\n    }),\n    [contractAddress, chainId, provider, amount, manifoldParams, address],\n  );\n\n  // Watch for transaction completion\n  const {\n    isSuccess: isTxSuccess,\n    isError: isTxError,\n    error: txError,\n  } = useWaitForTransactionReceipt({\n    hash: writeData,\n  });\n\n  // Get provider config\n  const providerConfig = contractInfo\n    ? getProviderConfig(contractInfo.provider)\n    : null;\n\n  // Check if user is on the correct network\n  const isCorrectNetwork = chain?.id === chainId;\n  const networkName = chainId === 1 ? \"Ethereum\" : chainId === 8453 ? \"Base\" : \"Unknown\";\n\n  // Handle transaction status updates\n  React.useEffect(() => {\n    if (writeError) {\n      const parsed = parseError(writeError, txType || \"mint\");\n      \n      // Don't show error state for user rejections - just close\n      if (parsed.type === \"user-rejected\") {\n        dispatch({ type: \"RESET\" });\n        setParsedError(null);\n        return;\n      }\n      \n      setParsedError(parsed);\n      dispatch({ type: \"TX_ERROR\", payload: writeError.message });\n      if (txType === \"mint\") {\n        onMintError?.(writeError.message);\n      }\n    }\n    if (isTxError && txError) {\n      const parsed = parseError(txError, txType || \"mint\");\n      setParsedError(parsed);\n      dispatch({ type: \"TX_ERROR\", payload: txError.message });\n      if (txType === \"mint\") {\n        onMintError?.(txError.message);\n      }\n    }\n    if (writeData && !isTxSuccess && !isTxError) {\n      // Transaction submitted, waiting for confirmation\n      if (txType === \"approval\") {\n        dispatch({ type: \"APPROVE_TX_SUBMITTED\", payload: writeData });\n      } else if (txType === \"mint\") {\n        dispatch({ type: \"MINT_TX_SUBMITTED\", payload: writeData });\n      }\n    }\n    if (isTxSuccess && writeData) {\n      if (txType === \"approval\") {\n        dispatch({ type: \"APPROVE_SUCCESS\" });\n      } else if (txType === \"mint\") {\n        dispatch({ type: \"TX_SUCCESS\", payload: writeData });\n        onMintSuccess?.(writeData);\n      }\n    }\n  }, [\n    isTxSuccess,\n    writeData,\n    onMintSuccess,\n    isTxError,\n    txError,\n    onMintError,\n    writeError,\n    txType,\n  ]);\n\n  // Auto-close on success after 10 seconds\n  React.useEffect(() => {\n    if (step === \"success\") {\n      const timer = setTimeout(() => {\n        handleClose();\n      }, 10000);\n      return () => clearTimeout(timer);\n    }\n  }, [step]);\n\n  const handleClose = React.useCallback(() => {\n    setIsSheetOpen(false);\n    dispatch({ type: \"RESET\" });\n    setParsedError(null);\n  }, []);\n\n  const handleSwitchNetwork = async () => {\n    try {\n      await switchChain({ chainId });\n    } catch (err) {\n      // Network switch failed - user likely rejected or wallet doesn't support it\n    }\n  };\n\n  // Detect NFT provider and validate\n  const detectAndValidate = async () => {\n    dispatch({ type: \"DETECT_START\" });\n\n    try {\n      // Detect provider\n      const info = await detectNFTProvider(mintParams);\n\n      // Validate parameters\n      const validation = validateParameters(mintParams, info);\n\n      if (!validation.isValid) {\n        dispatch({ type: \"VALIDATION_ERROR\", payload: validation.errors });\n        return;\n      }\n\n      // Fetch optimized price data\n      const client = getClientForChain(chainId);\n      const fetchedPriceData = await fetchPriceData(client, mintParams, info);\n\n      // Update contract info with ERC20 details and claim data\n      if (fetchedPriceData.erc20Details) {\n        info.erc20Token = fetchedPriceData.erc20Details\n          .address as `0x${string}`;\n        info.erc20Symbol = fetchedPriceData.erc20Details.symbol;\n        info.erc20Decimals = fetchedPriceData.erc20Details.decimals;\n      }\n\n      // Add claim data if available\n      if (fetchedPriceData.claim) {\n        info.claim = fetchedPriceData.claim;\n      }\n\n      dispatch({\n        type: \"DETECT_SUCCESS\",\n        payload: {\n          contractInfo: info,\n          priceData: {\n            mintPrice: fetchedPriceData.mintPrice,\n            totalCost: fetchedPriceData.totalCost,\n            erc20Details: fetchedPriceData.erc20Details,\n          },\n        },\n      });\n    } catch (err) {\n      dispatch({\n        type: \"DETECT_ERROR\",\n        payload: \"Failed to detect NFT contract type\",\n      });\n    }\n  };\n\n  // Check allowance only (without re-detecting everything)\n  const checkAllowanceOnly = React.useCallback(async () => {\n    if (!contractInfo || !erc20Details || !address) return;\n\n    try {\n      const client = getClientForChain(chainId);\n      const spenderAddress =\n        contractInfo.provider === \"manifold\" && contractInfo.extensionAddress\n          ? contractInfo.extensionAddress\n          : contractAddress;\n\n      const allowance = await client.readContract({\n        address: erc20Details.address as `0x${string}`,\n        abi: [\n          {\n            name: \"allowance\",\n            type: \"function\",\n            inputs: [\n              { name: \"owner\", type: \"address\" },\n              { name: \"spender\", type: \"address\" },\n            ],\n            outputs: [{ type: \"uint256\" }],\n            stateMutability: \"view\",\n          },\n        ],\n        functionName: \"allowance\",\n        args: [address, spenderAddress],\n      });\n\n      dispatch({ type: \"UPDATE_ALLOWANCE\", payload: allowance as bigint });\n    } catch (err) {\n      // Allowance check failed - will proceed without pre-checked allowance\n    }\n  }, [contractInfo, erc20Details, address, chainId, contractAddress]);\n\n  // Re-check allowance after wallet connection\n  React.useEffect(() => {\n    if (\n      isConnected &&\n      address &&\n      erc20Details &&\n      erc20Details.allowance === undefined\n    ) {\n      checkAllowanceOnly();\n    }\n  }, [isConnected, address, erc20Details, checkAllowanceOnly]);\n\n  const handleInitialMint = async () => {\n    if (!isSDKLoaded) {\n      dispatch({ type: \"TX_ERROR\", payload: \"Farcaster SDK not loaded\" });\n      setIsSheetOpen(true);\n      return;\n    }\n\n    setIsSheetOpen(true);\n    await detectAndValidate();\n  };\n\n  const handleConnectWallet = async () => {\n    try {\n      dispatch({ type: \"CONNECT_START\" });\n      const connector = farcasterFrame();\n      connect({ connector });\n    } catch (err) {\n      handleError(err, \"Failed to connect wallet\");\n    }\n  };\n\n  const handleApprove = async () => {\n    if (!isConnected || !erc20Details || !contractInfo?.claim) {\n      dispatch({\n        type: \"TX_ERROR\",\n        payload: \"Missing required information for approval\",\n      });\n      return;\n    }\n\n    try {\n      dispatch({ type: \"APPROVE_START\" });\n\n      // For Manifold, approve the extension contract, not the NFT contract\n      const spenderAddress =\n        contractInfo.provider === \"manifold\" && contractInfo.extensionAddress\n          ? contractInfo.extensionAddress\n          : contractAddress;\n\n      // Approve exact amount needed\n      await writeContract({\n        address: erc20Details.address as `0x${string}`,\n        abi: [\n          {\n            name: \"approve\",\n            type: \"function\",\n            inputs: [\n              { name: \"spender\", type: \"address\" },\n              { name: \"amount\", type: \"uint256\" },\n            ],\n            outputs: [{ type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n          },\n        ],\n        functionName: \"approve\",\n        args: [spenderAddress, contractInfo.claim.cost],\n        chainId,\n      });\n      \n      // The transaction has been initiated - we'll track it via writeData in the effect\n    } catch (err) {\n      handleError(err, \"Approval failed\", \"approval\");\n    }\n  };\n\n  const handleMint = async () => {\n    if (!isConnected) {\n      await handleConnectWallet();\n      return;\n    }\n\n    if (!contractInfo || !providerConfig) {\n      dispatch({\n        type: \"TX_ERROR\",\n        payload: \"Contract information not available\",\n      });\n      return;\n    }\n\n    try {\n      dispatch({ type: \"MINT_START\" });\n\n      const args = providerConfig.mintConfig.buildArgs(mintParams);\n      const value = priceData.mintPrice\n        ? providerConfig.mintConfig.calculateValue(\n            priceData.mintPrice,\n            mintParams,\n          )\n        : BigInt(0);\n\n      // Handle Manifold's special case\n      const mintAddress =\n        contractInfo.provider === \"manifold\" && contractInfo.extensionAddress\n          ? contractInfo.extensionAddress\n          : contractAddress;\n\n      await writeContract({\n        address: mintAddress,\n        abi: providerConfig.mintConfig.abi,\n        functionName: providerConfig.mintConfig.functionName as any,\n        args,\n        value,\n        chainId,\n      });\n      \n      // The transaction has been initiated - we'll track it via writeData in the effect\n    } catch (err) {\n      handleError(err, \"Mint transaction failed\", \"mint\");\n    }\n  };\n\n  // Centralized error handler\n  const handleError = (\n    error: unknown,\n    context: string,\n    transactionType?: \"approval\" | \"mint\",\n  ) => {\n    console.error(`${context}:`, error);\n    const message = error instanceof Error ? error.message : `${context}`;\n    \n    // Parse the error for better UX\n    const parsed = parseError(error, transactionType || \"mint\");\n    setParsedError(parsed);\n    \n    dispatch({ type: \"TX_ERROR\", payload: message });\n    // Use explicit transaction type if provided, otherwise fall back to state\n    if ((transactionType || txType) === \"mint\") {\n      onMintError?.(message);\n    }\n  };\n\n  const handleRetry = () => {\n    dispatch({ type: \"RESET\" });\n    detectAndValidate();\n  };\n\n  // Display helpers (quick win: centralized formatting)\n  const formatPrice = (amount: bigint, decimals: number, symbol: string) => {\n    if (amount === BigInt(0)) return \"Free\";\n    return `${Number(amount) / 10 ** decimals} ${symbol}`;\n  };\n\n  const displayPrice = () => {\n    if (erc20Details && contractInfo?.claim) {\n      return formatPrice(\n        contractInfo.claim.cost || BigInt(0),\n        erc20Details.decimals || 18,\n        erc20Details.symbol,\n      );\n    }\n    return priceData.mintPrice\n      ? `${formatEther(priceData.mintPrice)} ETH`\n      : \"Free\";\n  };\n\n  const displayTotalCost = () => {\n    if (erc20Details && contractInfo?.claim) {\n      // For Manifold, cost is per claim, not per NFT amount\n      return formatPrice(\n        contractInfo.claim.cost || BigInt(0),\n        erc20Details.decimals || 18,\n        erc20Details.symbol,\n      );\n    }\n    return priceData.totalCost\n      ? `${formatEther(priceData.totalCost)} ETH`\n      : \"Free\";\n  };\n\n  const displayMintFee = () => {\n    const fee = priceData.mintPrice || BigInt(0);\n    return fee > BigInt(0) ? `${formatEther(fee)} ETH` : \"0 ETH\";\n  };\n\n  const providerName = contractInfo?.provider\n    ? contractInfo.provider.charAt(0).toUpperCase() +\n      contractInfo.provider.slice(1)\n    : \"Unknown\";\n\n  // Quick win: validation helper\n  const isReadyToMint = () => {\n    return (\n      isConnected &&\n      contractInfo &&\n      !isLoading &&\n      step === \"sheet\" &&\n      (!erc20Details || !erc20Details.needsApproval)\n    );\n  };\n\n  return (\n    <Sheet\n      open={isSheetOpen}\n      onOpenChange={(open) => {\n        setIsSheetOpen(open);\n        if (!open) {\n          handleClose();\n        }\n      }}\n    >\n      <Button\n        variant={variant}\n        size={size}\n        onClick={handleInitialMint}\n        disabled={disabled || !isSDKLoaded || isLoading}\n        className={cn(\"w-full\", className)}\n      >\n        <Coins className=\"h-4 w-4 mr-2\" />\n        {buttonText}\n      </Button>\n\n      <SheetContent\n        side=\"bottom\"\n        onClose={handleClose}\n        className=\"!bottom-0 !rounded-t-xl !rounded-b-none !max-h-[90vh] !h-auto\"\n      >\n        <SheetHeader className=\"mb-6\">\n          <SheetTitle>\n            {step === \"detecting\" && \"Detecting NFT Type\"}\n            {step === \"sheet\" && \"Mint NFT\"}\n            {step === \"connecting\" && \"Connecting Wallet\"}\n            {step === \"approve\" && \"Approve Token\"}\n            {step === \"approving\" && \"Approving...\"}\n            {step === \"minting\" && \"Preparing Mint\"}\n            {step === \"waiting\" &&\n              (txType === \"approval\" ? \"Approving...\" : \"Minting...\")}\n            {step === \"success\" && \"Mint Successful!\"}\n            {step === \"error\" && \"Transaction Failed\"}\n            {step === \"validation-error\" && \"Missing Information\"}\n          </SheetTitle>\n        </SheetHeader>\n\n        {/* Detecting Provider */}\n        {step === \"detecting\" && (\n          <div className=\"text-center space-y-4\">\n            <div className=\"flex justify-center\">\n              <Loader2 className=\"h-12 w-12 animate-spin text-primary\" />\n            </div>\n            <p className=\"text-muted-foreground\">\n              Detecting NFT contract type...\n            </p>\n          </div>\n        )}\n\n        {/* Validation Error */}\n        {step === \"validation-error\" && (\n          <div className=\"space-y-4\">\n            <div className=\"flex justify-center\">\n              <Info className=\"h-12 w-12 text-yellow-500\" />\n            </div>\n            <div className=\"space-y-2\">\n              <p className=\"font-semibold text-center\">\n                Missing Required Information\n              </p>\n              {validationErrors.map((err, idx) => (\n                <p\n                  key={idx}\n                  className=\"text-sm text-muted-foreground text-center\"\n                >\n                  {err}\n                </p>\n              ))}\n            </div>\n            <Button onClick={handleClose} className=\"w-full\">\n              Close\n            </Button>\n          </div>\n        )}\n\n        {/* Approve Step */}\n        {step === \"approve\" && erc20Details && (\n          <div className=\"space-y-6\">\n            <div className=\"text-center space-y-2\">\n              <p className=\"font-semibold\">Approval Required</p>\n              <p className=\"text-sm text-muted-foreground\">\n                This NFT requires payment in {erc20Details.symbol}. You need to\n                approve the contract to spend your tokens.\n              </p>\n            </div>\n            <div className=\"space-y-4\">\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Token</span>\n                <span className=\"font-semibold\">{erc20Details.symbol}</span>\n              </div>\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Amount to Approve</span>\n                <span className=\"font-semibold\">\n                  {contractInfo?.claim\n                    ? Number(contractInfo.claim.cost) /\n                      10 ** erc20Details.decimals\n                    : 0}{\" \"}\n                  {erc20Details.symbol}\n                </span>\n              </div>\n            </div>\n            <Button\n              onClick={handleApprove}\n              size=\"lg\"\n              className=\"w-full\"\n              disabled={isWritePending}\n            >\n              <Coins className=\"h-5 w-5 mr-2\" />\n              Approve {erc20Details.symbol}\n            </Button>\n          </div>\n        )}\n\n        {/* Main Sheet Content */}\n        {step === \"sheet\" && contractInfo && (\n          <div className=\"space-y-6\">\n            {/* Network warning */}\n            {!isCorrectNetwork && isConnected && (\n              <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-3\">\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex items-center gap-2\">\n                    <Info className=\"h-4 w-4 text-yellow-600\" />\n                    <p className=\"text-sm font-medium\">Wrong network</p>\n                  </div>\n                  <Button\n                    onClick={handleSwitchNetwork}\n                    size=\"sm\"\n                    variant=\"ghost\"\n                    className=\"text-xs\"\n                  >\n                    Switch to {networkName}\n                  </Button>\n                </div>\n              </div>\n            )}\n            \n            <div className=\"space-y-4\">\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Provider</span>\n                <span className=\"font-semibold\">{providerName}</span>\n              </div>\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Contract</span>\n                <span className=\"font-mono text-sm\">\n                  {contractAddress.slice(0, 6)}...{contractAddress.slice(-4)}\n                </span>\n              </div>\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Quantity</span>\n                <span className=\"font-semibold\">{amount}</span>\n              </div>\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Price per NFT</span>\n                <span className=\"font-semibold\">{displayPrice()}</span>\n              </div>\n              {erc20Details && (\n                <div className=\"flex justify-between items-center py-3 border-b\">\n                  <span className=\"text-muted-foreground\">Mint Fee</span>\n                  <span className=\"font-semibold\">{displayMintFee()}</span>\n                </div>\n              )}\n              <div className=\"flex justify-between items-center py-3 text-lg font-semibold\">\n                <span>Total Cost</span>\n                <span>{displayTotalCost()}</span>\n              </div>\n            </div>\n\n            <Button\n              onClick={isConnected ? handleMint : handleConnectWallet}\n              size=\"lg\"\n              className=\"w-full\"\n              disabled={isWritePending || !isReadyToMint() || (!isCorrectNetwork && isConnected)}\n            >\n              {isConnected ? (\n                !isCorrectNetwork ? (\n                  \"Switch Network to Mint\"\n                ) : (\n                  <>\n                    <Coins className=\"h-5 w-5 mr-2\" />\n                    Mint {amount} NFT{amount > 1 ? \"s\" : \"\"}\n                  </>\n                )\n              ) : (\n                \"Connect Wallet to Mint\"\n              )}\n            </Button>\n          </div>\n        )}\n\n        {/* Connecting */}\n        {step === \"connecting\" && (\n          <div className=\"text-center space-y-4\">\n            <div className=\"flex justify-center\">\n              <Loader2 className=\"h-12 w-12 animate-spin text-primary\" />\n            </div>\n            <p className=\"text-muted-foreground\">\n              Connecting to your Farcaster wallet...\n            </p>\n          </div>\n        )}\n\n        {/* Minting/Approving */}\n        {(step === \"minting\" || step === \"approving\") && (\n          <div className=\"text-center space-y-4\">\n            <div className=\"flex justify-center\">\n              <Loader2 className=\"h-12 w-12 animate-spin text-primary\" />\n            </div>\n            <div>\n              <p className=\"font-semibold\">\n                {step === \"approving\"\n                  ? \"Preparing approval\"\n                  : \"Preparing mint transaction\"}\n              </p>\n              <p className=\"text-sm text-muted-foreground\">\n                Please approve the transaction in your wallet\n              </p>\n            </div>\n          </div>\n        )}\n\n        {/* Waiting for Transaction */}\n        {step === \"waiting\" && (\n          <div className=\"text-center space-y-4\">\n            <div className=\"flex justify-center\">\n              <Loader2 className=\"h-12 w-12 animate-spin text-primary\" />\n            </div>\n            <div>\n              <p className=\"font-semibold\">\n                {txType === \"approval\"\n                  ? \"Approval submitted\"\n                  : \"Transaction submitted\"}\n              </p>\n              <p className=\"text-sm text-muted-foreground\">\n                Waiting for confirmation on the blockchain...\n              </p>\n              {txHash && (\n                <p className=\"text-xs font-mono mt-2 px-3 py-1 bg-muted rounded\">\n                  {txHash.slice(0, 10)}...{txHash.slice(-8)}\n                </p>\n              )}\n            </div>\n          </div>\n        )}\n\n        {/* Success */}\n        {step === \"success\" && (\n          <div className=\"text-center space-y-6\">\n            <div className=\"flex justify-center\">\n              <CheckCircle className=\"h-20 w-20 text-green-500\" />\n            </div>\n            <div className=\"space-y-3\">\n              <p className=\"text-2xl font-semibold\">Minted! 🎉</p>\n              <p className=\"text-muted-foreground\">\n                {amount} NFT{amount > 1 ? \"s\" : \"\"} successfully minted\n              </p>\n            </div>\n            {txHash && (\n              <div className=\"space-y-3\">\n                <Button variant=\"outline\" size=\"sm\" className=\"gap-2\" asChild>\n                  <a\n                    href={`https://txha.sh/${txHash}`}\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                  >\n                    View transaction\n                    <ExternalLink className=\"h-3 w-3\" />\n                  </a>\n                </Button>\n              </div>\n            )}\n            <Button onClick={handleClose} className=\"w-full\" size=\"lg\">\n              Done\n            </Button>\n          </div>\n        )}\n\n        {/* Error State */}\n        {step === \"error\" && (\n          <div className=\"space-y-6\">\n            <div className=\"text-center space-y-4\">\n              <div className=\"flex justify-center\">\n                <div className=\"p-3 bg-red-50 rounded-full\">\n                  <AlertCircle className=\"h-12 w-12 text-red-500\" />\n                </div>\n              </div>\n              <div className=\"space-y-2\">\n                <p className=\"font-semibold text-lg\">\n                  {parsedError?.message || \"Transaction Failed\"}\n                </p>\n                {parsedError?.details && (\n                  <p className=\"text-sm text-muted-foreground max-w-sm mx-auto\">\n                    {parsedError.details}\n                  </p>\n                )}\n              </div>\n            </div>\n\n            {/* Special handling for wrong network */}\n            {!isCorrectNetwork && isConnected && (\n              <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-4 space-y-3\">\n                <div className=\"flex items-center gap-2\">\n                  <Info className=\"h-5 w-5 text-yellow-600 flex-shrink-0\" />\n                  <div>\n                    <p className=\"font-medium text-sm\">Wrong Network</p>\n                    <p className=\"text-sm text-muted-foreground\">\n                      Please switch to {networkName} to continue\n                    </p>\n                  </div>\n                </div>\n                <Button\n                  onClick={handleSwitchNetwork}\n                  size=\"sm\"\n                  className=\"w-full\"\n                  variant=\"outline\"\n                >\n                  Switch to {networkName}\n                </Button>\n              </div>\n            )}\n\n            {/* Specific error actions */}\n            {parsedError?.type === \"insufficient-funds\" && (\n              <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4\">\n                <div className=\"flex items-start gap-2\">\n                  <Wallet className=\"h-5 w-5 text-blue-600 flex-shrink-0 mt-0.5\" />\n                  <div className=\"text-sm\">\n                    <p className=\"font-medium mb-1\">Insufficient Balance</p>\n                    <p className=\"text-muted-foreground\">\n                      Make sure you have enough:\n                    </p>\n                    <ul className=\"list-disc list-inside text-muted-foreground mt-1\">\n                      {erc20Details ? (\n                        <>\n                          <li>{erc20Details.symbol} for the NFT price</li>\n                          <li>ETH for gas fees</li>\n                        </>\n                      ) : (\n                        <li>ETH for both NFT price and gas fees</li>\n                      )}\n                    </ul>\n                  </div>\n                </div>\n              </div>\n            )}\n\n            {/* Action buttons */}\n            <div className=\"flex gap-3\">\n              <Button\n                variant=\"outline\"\n                onClick={handleClose}\n                className=\"flex-1\"\n              >\n                Close\n              </Button>\n              <Button \n                onClick={handleRetry} \n                className=\"flex-1\"\n                disabled={!isCorrectNetwork && isConnected}\n              >\n                <RefreshCw className=\"h-4 w-4 mr-2\" />\n                {parsedError?.actionText || \"Try Again\"}\n              </Button>\n            </div>\n          </div>\n        )}\n      </SheetContent>\n    </Sheet>\n  );\n}\n\n/**\n * Preset builders for common NFT minting scenarios.\n * These provide type-safe, self-documenting ways to create NFTMintFlow components.\n */\nNFTMintFlow.presets = {\n  /**\n   * Create a basic ETH-based NFT mint\n   * @example\n   * ```tsx\n   * <NFTMintFlow {...NFTMintFlow.presets.generic({\n   *   contractAddress: \"0x5b97886E4e1fC0F7d19146DEC03C917994b3c3a4\",\n   *   chainId: 1,\n   *   amount: 1\n   * })} />\n   * ```\n   */\n  generic: (props: {\n    contractAddress: Address;\n    chainId: 1 | 8453;\n    amount?: number;\n    buttonText?: string;\n    onMintSuccess?: (txHash: string) => void;\n    onMintError?: (error: string) => void;\n  }): NFTMintFlowProps => ({\n    ...props,\n    provider: \"generic\",\n    amount: props.amount || 1,\n  }),\n\n  /**\n   * Create a Manifold NFT mint with proper configuration\n   * @example\n   * ```tsx\n   * <NFTMintFlow {...NFTMintFlow.presets.manifold({\n   *   contractAddress: \"0x32dd0a7190b5bba94549a0d04659a9258f5b1387\",\n   *   chainId: 8453,\n   *   instanceId: \"4293509360\"\n   * })} />\n   * ```\n   */\n  manifold: (props: {\n    contractAddress: Address;\n    chainId: 1 | 8453;\n    instanceId: string;\n    tokenId?: string;\n    amount?: number;\n    buttonText?: string;\n    onMintSuccess?: (txHash: string) => void;\n    onMintError?: (error: string) => void;\n  }): NFTMintFlowProps => ({\n    contractAddress: props.contractAddress,\n    chainId: props.chainId,\n    provider: \"manifold\",\n    manifoldParams: {\n      instanceId: props.instanceId,\n      tokenId: props.tokenId,\n    },\n    amount: props.amount || 1,\n    buttonText: props.buttonText,\n    onMintSuccess: props.onMintSuccess,\n    onMintError: props.onMintError,\n  }),\n\n  /**\n   * Create an auto-detecting NFT mint (tries to figure out the provider)\n   * @example\n   * ```tsx\n   * <NFTMintFlow {...NFTMintFlow.presets.auto({\n   *   contractAddress: \"0x...\",\n   *   chainId: 8453\n   * })} />\n   * ```\n   */\n  auto: (props: {\n    contractAddress: Address;\n    chainId: 1 | 8453;\n    amount?: number;\n    buttonText?: string;\n    onMintSuccess?: (txHash: string) => void;\n    onMintError?: (error: string) => void;\n  }): NFTMintFlowProps => ({\n    ...props,\n    amount: props.amount || 1,\n  }),\n};\n",
      "type": "registry:block"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/lib/types.ts",
      "content": "import type { Address } from \"viem\";\n\nexport type NFTProvider = \"manifold\" | \"opensea\" | \"zora\" | \"generic\";\n\nexport interface ProviderConfig {\n  name: NFTProvider;\n  detectPattern?: RegExp;\n  extensionAddresses?: Address[];\n  priceDiscovery: PriceDiscoveryConfig;\n  mintConfig: MintConfig;\n  requiredParams: string[];\n  supportsERC20: boolean;\n}\n\nexport interface PriceDiscoveryConfig {\n  abis: any[];\n  functionNames: string[];\n  requiresInstanceId?: boolean;\n}\n\nexport interface MintConfig {\n  abi: any;\n  functionName: string;\n  buildArgs: (params: MintParams) => any[];\n  calculateValue: (price: bigint, params: MintParams) => bigint;\n}\n\nexport interface MintParams {\n  contractAddress: Address;\n  chainId: number;\n  provider?: NFTProvider;\n  amount?: number;\n  instanceId?: string;\n  tokenId?: string;\n  recipient?: Address;\n  merkleProof?: string[];\n}\n\nexport interface NFTContractInfo {\n  provider: NFTProvider;\n  isERC1155: boolean;\n  isERC721: boolean;\n  extensionAddress?: Address;\n  hasManifoldExtension?: boolean;\n  mintPrice?: bigint;\n  erc20Token?: Address;\n  erc20Symbol?: string;\n  erc20Decimals?: number;\n  claim?: {\n    cost: bigint;\n    merkleRoot: `0x${string}`;\n    erc20: Address;\n    startDate: number;\n    endDate: number;\n    walletMax: number;\n  };\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  missingParams: string[];\n  errors: string[];\n  warnings: string[];\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/lib/provider-configs.ts",
      "content": "import { type Address } from \"viem\";\nimport type { ProviderConfig } from \"./types\";\nimport { MANIFOLD_EXTENSION_ABI, KNOWN_CONTRACTS, PRICE_DISCOVERY_ABI, MINT_ABI } from \"@/registry/mini-app/lib/nft-standards\";\n\nexport const PROVIDER_CONFIGS: Record<string, ProviderConfig> = {\n  manifold: {\n    name: \"manifold\",\n    extensionAddresses: [\n      KNOWN_CONTRACTS.manifoldExtension, // Known Manifold extension\n    ],\n    priceDiscovery: {\n      abis: [MANIFOLD_EXTENSION_ABI],\n      functionNames: [\"MINT_FEE\"],\n      requiresInstanceId: true\n    },\n    mintConfig: {\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"mint\",\n      buildArgs: (params) => [\n        params.contractAddress,\n        BigInt(params.instanceId || \"0\"),\n        Number(params.tokenId || \"0\"),\n        params.merkleProof || [],\n        params.recipient\n      ],\n      calculateValue: (mintFee, params) => {\n        // For Manifold, value is just the mint fee\n        // The actual NFT cost might be in ERC20\n        return mintFee;\n      }\n    },\n    requiredParams: [\"contractAddress\", \"chainId\"],\n    supportsERC20: true\n  },\n  \n  opensea: {\n    name: \"opensea\",\n    priceDiscovery: {\n      abis: [PRICE_DISCOVERY_ABI],\n      functionNames: [\"mintPrice\", \"price\", \"publicMintPrice\"]\n    },\n    mintConfig: {\n      abi: MINT_ABI,\n      functionName: \"mint\",\n      buildArgs: (params) => [BigInt(params.amount || 1)],\n      calculateValue: (price, params) => price * BigInt(params.amount || 1)\n    },\n    requiredParams: [\"contractAddress\", \"chainId\"],\n    supportsERC20: false\n  },\n\n  zora: {\n    name: \"zora\",\n    priceDiscovery: {\n      abis: [PRICE_DISCOVERY_ABI],\n      functionNames: [\"mintPrice\", \"price\"]\n    },\n    mintConfig: {\n      abi: MINT_ABI,\n      functionName: \"mint\",\n      buildArgs: (params) => [params.recipient, BigInt(params.amount || 1)],\n      calculateValue: (price, params) => price * BigInt(params.amount || 1)\n    },\n    requiredParams: [\"contractAddress\", \"chainId\"],\n    supportsERC20: false\n  },\n\n  generic: {\n    name: \"generic\",\n    priceDiscovery: {\n      abis: [PRICE_DISCOVERY_ABI],\n      functionNames: [\"mintPrice\", \"price\", \"MINT_PRICE\", \"getMintPrice\"]\n    },\n    mintConfig: {\n      abi: MINT_ABI,\n      functionName: \"mint\",\n      buildArgs: (params) => [BigInt(params.amount || 1)],\n      calculateValue: (price, params) => price * BigInt(params.amount || 1)\n    },\n    requiredParams: [\"contractAddress\", \"chainId\"],\n    supportsERC20: false\n  }\n};\n\n// Helper to get config by provider name\nexport function getProviderConfig(provider: string): ProviderConfig {\n  return PROVIDER_CONFIGS[provider] || PROVIDER_CONFIGS.generic;\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/lib/provider-detector.ts",
      "content": "import { type Address, type PublicClient } from \"viem\";\nimport type { NFTProvider, NFTContractInfo, MintParams } from \"./types\";\nimport { PROVIDER_CONFIGS } from \"./provider-configs\";\nimport { getPublicClient } from \"@/registry/mini-app/lib/chains\";\nimport { \n  ERC165_ABI, \n  INTERFACE_IDS, \n  MANIFOLD_DETECTION_ABI \n} from \"@/registry/mini-app/lib/nft-standards\";\n\n// Re-export from shared library for backward compatibility\nexport const getClientForChain = getPublicClient;\n\n/**\n * Detects NFT provider and contract info with minimal RPC calls\n * Uses multicall where possible to batch requests\n */\nexport async function detectNFTProvider(params: MintParams): Promise<NFTContractInfo> {\n  const { contractAddress, chainId, provider: specifiedProvider } = params;\n  const client = getClientForChain(chainId);\n\n  // If provider is specified, use known configuration\n  if (specifiedProvider) {\n    const config = PROVIDER_CONFIGS[specifiedProvider];\n    \n    // For Manifold, we know the extension address\n    if (specifiedProvider === \"manifold\" && config.extensionAddresses?.[0]) {\n      return {\n        provider: \"manifold\",\n        isERC1155: true,  // Manifold contracts are typically ERC1155\n        isERC721: false,\n        extensionAddress: config.extensionAddresses[0],\n        hasManifoldExtension: true\n      };\n    }\n    \n    // For other providers, return basic info\n    return {\n      provider: specifiedProvider,\n      isERC1155: false,\n      isERC721: false\n    };\n  }\n\n  try {\n    // Batch 1: Check interfaces and Manifold extensions in parallel\n    const [isERC721, isERC1155, extensions] = await Promise.all([\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: \"supportsInterface\",\n        args: [INTERFACE_IDS.ERC721]\n      }).catch(() => false),\n      \n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: \"supportsInterface\",\n        args: [INTERFACE_IDS.ERC1155]\n      }).catch(() => false),\n      \n      client.readContract({\n        address: contractAddress,\n        abi: MANIFOLD_DETECTION_ABI,\n        functionName: \"getExtensions\"\n      }).catch(() => null)\n    ]);\n\n    // Check if it's a Manifold contract\n    if (extensions && extensions.length > 0) {\n      const knownManifoldExtension = extensions.find(ext => \n        PROVIDER_CONFIGS.manifold.extensionAddresses?.includes(ext)\n      );\n      \n      if (knownManifoldExtension || extensions.length > 0) {\n        return {\n          provider: \"manifold\",\n          isERC1155: isERC1155 as boolean,\n          isERC721: isERC721 as boolean,\n          extensionAddress: knownManifoldExtension || extensions[0],\n          hasManifoldExtension: true\n        };\n      }\n    }\n\n    // TODO: Add detection for OpenSea, Zora, etc.\n    // For now, return generic\n    return {\n      provider: \"generic\",\n      isERC1155: isERC1155 as boolean,\n      isERC721: isERC721 as boolean\n    };\n\n  } catch (error) {\n    console.error(\"Error detecting NFT provider:\", error);\n    // Default to generic provider\n    return {\n      provider: \"generic\",\n      isERC1155: false,\n      isERC721: false\n    };\n  }\n}\n\n/**\n * Validates parameters based on detected provider\n */\nexport function validateParameters(params: MintParams, contractInfo: NFTContractInfo): {\n  isValid: boolean;\n  missingParams: string[];\n  errors: string[];\n} {\n  const config = PROVIDER_CONFIGS[contractInfo.provider];\n  const missingParams: string[] = [];\n  const errors: string[] = [];\n\n  // Check required params for the provider\n  for (const param of config.requiredParams) {\n    if (!params[param as keyof MintParams]) {\n      missingParams.push(param);\n    }\n  }\n\n  // Provider-specific validation\n  if (contractInfo.provider === \"manifold\") {\n    if (!params.instanceId && !params.tokenId) {\n      errors.push(\"Manifold NFTs require either instanceId or tokenId\");\n      missingParams.push(\"instanceId or tokenId\");\n    }\n    \n    if (contractInfo.claim?.merkleRoot && contractInfo.claim.merkleRoot !== \"0x0000000000000000000000000000000000000000000000000000000000000000\") {\n      errors.push(\"This NFT requires a merkle proof for minting - not supported yet\");\n    }\n  }\n\n  return {\n    isValid: missingParams.length === 0 && errors.length === 0,\n    missingParams,\n    errors\n  };\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/lib/price-optimizer.ts",
      "content": "import type { PublicClient } from \"viem\";\nimport type { NFTContractInfo, MintParams } from \"./types\";\nimport { getProviderConfig } from \"./provider-configs\";\n\n/**\n * Optimized price discovery that batches RPC calls where possible\n */\nexport async function fetchPriceData(\n  client: PublicClient,\n  params: MintParams,\n  contractInfo: NFTContractInfo\n): Promise<{\n  mintPrice?: bigint;\n  erc20Details?: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    allowance?: bigint;\n    balance?: bigint;\n  };\n  totalCost: bigint;\n  claim?: NFTContractInfo[\"claim\"];\n}> {\n  const config = getProviderConfig(contractInfo.provider);\n  \n  if (contractInfo.provider === \"manifold\" && contractInfo.extensionAddress) {\n    // For Manifold, we need extension fee + claim cost\n    const calls = [\n      // Get MINT_FEE from extension\n      {\n        address: contractInfo.extensionAddress,\n        abi: config.mintConfig.abi,\n        functionName: \"MINT_FEE\",\n        args: []\n      }\n    ];\n    \n    // Add claim fetch if we have instanceId\n    if (params.instanceId) {\n      calls.push({\n        address: contractInfo.extensionAddress,\n        abi: config.mintConfig.abi,\n        functionName: \"getClaim\",\n        args: [params.contractAddress, BigInt(params.instanceId)]\n      } as any);\n    }\n    \n    try {\n      const results = await Promise.all(\n        calls.map(call => \n          client.readContract(call as any).catch(err => {\n            console.error(\"RPC call failed:\", err);\n            return null;\n          })\n        )\n      );\n      \n      const mintFee = results[0] as bigint | null;\n      const claim = results[1] as any;\n      \n      let totalCost = mintFee || BigInt(0);\n      let erc20Details = undefined;\n      \n      if (claim) {\n        // Store claim data in contractInfo for later use\n        contractInfo.claim = {\n          cost: claim.cost,\n          merkleRoot: claim.merkleRoot,\n          erc20: claim.erc20,\n          startDate: claim.startDate,\n          endDate: claim.endDate,\n          walletMax: claim.walletMax\n        };\n        \n        // Check if ERC20 payment\n        if (claim.erc20 && claim.erc20 !== \"0x0000000000000000000000000000000000000000\") {\n          // Batch ERC20 details fetch\n          const [symbol, decimals, allowance, balance] = await Promise.all([\n            client.readContract({\n              address: claim.erc20,\n              abi: [{ name: \"symbol\", type: \"function\", inputs: [], outputs: [{ type: \"string\" }], stateMutability: \"view\" }],\n              functionName: \"symbol\"\n            }),\n            client.readContract({\n              address: claim.erc20,\n              abi: [{ name: \"decimals\", type: \"function\", inputs: [], outputs: [{ type: \"uint8\" }], stateMutability: \"view\" }],\n              functionName: \"decimals\"\n            }),\n            params.recipient ? client.readContract({\n              address: claim.erc20,\n              abi: [{ \n                name: \"allowance\", \n                type: \"function\", \n                inputs: [{ name: \"owner\", type: \"address\" }, { name: \"spender\", type: \"address\" }], \n                outputs: [{ type: \"uint256\" }], \n                stateMutability: \"view\" \n              }],\n              functionName: \"allowance\",\n              args: [params.recipient, contractInfo.extensionAddress || params.contractAddress]\n            }).catch(() => BigInt(0)) : Promise.resolve(undefined), // Return undefined when no recipient, not 0\n            params.recipient ? client.readContract({\n              address: claim.erc20,\n              abi: [{ \n                name: \"balanceOf\", \n                type: \"function\", \n                inputs: [{ name: \"owner\", type: \"address\" }], \n                outputs: [{ type: \"uint256\" }], \n                stateMutability: \"view\" \n              }],\n              functionName: \"balanceOf\",\n              args: [params.recipient]\n            }).catch(() => BigInt(0)) : Promise.resolve(undefined)\n          ]);\n          \n          // Validate decimals\n          const validatedDecimals = Number(decimals);\n          if (isNaN(validatedDecimals) || validatedDecimals < 0 || validatedDecimals > 255) {\n            console.error(`Invalid ERC20 decimals for ${claim.erc20}:`, decimals);\n            throw new Error(`Invalid ERC20 decimals: ${decimals}`);\n          }\n          \n          erc20Details = {\n            address: claim.erc20,\n            symbol: symbol as string,\n            decimals: validatedDecimals,\n            allowance: allowance as bigint,\n            balance: balance as bigint | undefined\n          };\n          \n          // For ERC20, total cost in ETH is just the mint fee\n          totalCost = mintFee || BigInt(0);\n        } else {\n          // ETH payment - add claim cost to mint fee\n          totalCost = (mintFee || BigInt(0)) + (claim.cost || BigInt(0));\n        }\n      }\n      \n      return {\n        mintPrice: mintFee || BigInt(0),\n        erc20Details,\n        totalCost,\n        claim: claim ? contractInfo.claim : undefined\n      };\n    } catch (err) {\n      console.error(\"Failed to fetch Manifold price data:\", err);\n      return { totalCost: BigInt(0) };\n    }\n  } else {\n    // Generic price discovery - try multiple function names\n    const functionNames = config.priceDiscovery.functionNames;\n    \n    for (const functionName of functionNames) {\n      try {\n        const price = await client.readContract({\n          address: params.contractAddress,\n          abi: config.priceDiscovery.abis[0],\n          functionName: functionName as any,\n          args: []\n        });\n        \n        if (price !== undefined) {\n          const totalCost = (price as bigint) * BigInt(params.amount || 1);\n          return {\n            mintPrice: price as bigint,\n            totalCost\n          };\n        }\n      } catch {\n        // Try next function name\n        continue;\n      }\n    }\n    \n    // No price found, assume free mint\n    return { mintPrice: BigInt(0), totalCost: BigInt(0) };\n  }\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/lib/mint-reducer.ts",
      "content": "import type { NFTContractInfo } from \"./types\";\n\nexport type MintStep = \"initial\" | \"detecting\" | \"sheet\" | \"connecting\" | \"approve\" | \"approving\" | \"minting\" | \"waiting\" | \"success\" | \"error\" | \"validation-error\";\n\nexport type TransactionType = \"approval\" | \"mint\" | null;\n\nexport type MintState = {\n  step: MintStep;\n  contractInfo: NFTContractInfo | null;\n  priceData: {\n    mintPrice?: bigint;\n    totalCost: bigint;\n    erc20Details?: {\n      address: string;\n      symbol: string;\n      decimals: number;\n      allowance?: bigint;\n      needsApproval?: boolean;\n    };\n  };\n  error?: string;\n  txHash?: string;\n  txType: TransactionType;\n  isLoading: boolean;\n  validationErrors: string[];\n};\n\nexport const initialState: MintState = {\n  step: \"initial\",\n  contractInfo: null,\n  priceData: { totalCost: BigInt(0) },\n  error: undefined,\n  txHash: undefined,\n  txType: null,\n  isLoading: false,\n  validationErrors: []\n};\n\nexport type MintAction = \n  | { type: \"DETECT_START\" }\n  | { type: \"DETECT_SUCCESS\"; payload: { contractInfo: NFTContractInfo; priceData: MintState[\"priceData\"] } }\n  | { type: \"DETECT_ERROR\"; payload: string }\n  | { type: \"VALIDATION_ERROR\"; payload: string[] }\n  | { type: \"APPROVE_REQUIRED\" }\n  | { type: \"APPROVE_START\" }\n  | { type: \"APPROVE_TX_SUBMITTED\"; payload: string }\n  | { type: \"APPROVE_SUCCESS\" }\n  | { type: \"CONNECT_START\" }\n  | { type: \"CONNECT_SUCCESS\" }\n  | { type: \"MINT_START\" }\n  | { type: \"MINT_TX_SUBMITTED\"; payload: string }\n  | { type: \"TX_SUCCESS\"; payload: string }\n  | { type: \"TX_ERROR\"; payload: string }\n  | { type: \"RESET\" }\n  | { type: \"UPDATE_ALLOWANCE\"; payload: bigint };\n\nexport function mintReducer(state: MintState, action: MintAction): MintState {\n  switch (action.type) {\n    case \"DETECT_START\":\n      return { ...state, step: \"detecting\", isLoading: true, error: undefined };\n      \n    case \"DETECT_SUCCESS\":\n      // Check if approval is needed based on allowance\n      const needsApproval = action.payload.priceData.erc20Details && \n        action.payload.contractInfo.claim &&\n        (action.payload.priceData.erc20Details.allowance !== undefined) &&\n        (action.payload.priceData.erc20Details.allowance < action.payload.contractInfo.claim.cost);\n        \n      return {\n        ...state,\n        step: needsApproval ? \"approve\" : \"sheet\",\n        contractInfo: action.payload.contractInfo,\n        priceData: {\n          ...action.payload.priceData,\n          erc20Details: action.payload.priceData.erc20Details ? {\n            ...action.payload.priceData.erc20Details,\n            needsApproval\n          } : undefined\n        },\n        isLoading: false\n      };\n      \n    case \"DETECT_ERROR\":\n      return { ...state, step: \"error\", error: action.payload, isLoading: false };\n      \n    case \"VALIDATION_ERROR\":\n      return { ...state, step: \"validation-error\", validationErrors: action.payload, isLoading: false };\n      \n    case \"APPROVE_REQUIRED\":\n      return { ...state, step: \"approve\" };\n      \n    case \"APPROVE_START\":\n      return { ...state, step: \"approving\", isLoading: true, txType: \"approval\" };\n      \n    case \"APPROVE_TX_SUBMITTED\":\n      return { ...state, step: \"waiting\", txHash: action.payload, txType: \"approval\" };\n      \n    case \"APPROVE_SUCCESS\":\n      return { \n        ...state, \n        step: \"sheet\", \n        isLoading: false,\n        txType: null,\n        txHash: undefined, // Clear tx hash after approval\n        priceData: {\n          ...state.priceData,\n          erc20Details: state.priceData.erc20Details ? {\n            ...state.priceData.erc20Details,\n            needsApproval: false,\n            allowance: state.contractInfo?.claim?.cost || BigInt(0)\n          } : undefined\n        }\n      };\n      \n    case \"CONNECT_START\":\n      return { ...state, step: \"connecting\" };\n      \n    case \"CONNECT_SUCCESS\":\n      return { ...state, step: \"sheet\" };\n      \n    case \"MINT_START\":\n      return { ...state, step: \"minting\", isLoading: true, txType: \"mint\" };\n      \n    case \"MINT_TX_SUBMITTED\":\n      return { ...state, step: \"waiting\", txHash: action.payload, txType: \"mint\" };\n      \n    case \"TX_SUCCESS\":\n      // Only show success for mint transactions\n      return state.txType === \"mint\" \n        ? { ...state, step: \"success\", txHash: action.payload, isLoading: false, txType: null }\n        : state;\n      \n    case \"TX_ERROR\":\n      return { ...state, step: \"error\", error: action.payload, isLoading: false, txType: null };\n      \n    case \"UPDATE_ALLOWANCE\":\n      if (!state.priceData.erc20Details) return state;\n      \n      const updatedNeedsApproval = state.contractInfo?.claim \n        ? action.payload < state.contractInfo.claim.cost\n        : false;\n        \n      return {\n        ...state,\n        priceData: {\n          ...state.priceData,\n          erc20Details: {\n            ...state.priceData.erc20Details,\n            allowance: action.payload,\n            needsApproval: updatedNeedsApproval\n          }\n        }\n      };\n      \n    case \"RESET\":\n      return initialState;\n      \n    default:\n      return state;\n  }\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/ui/button.tsx",
      "content": "import * as React from \"react\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nimport { cn } from \"@/registry/mini-app/lib/utils\";\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground shadow-xs hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  },\n);\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean;\n  }) {\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  );\n}\n\nexport { Button, buttonVariants };\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/ui/sheet.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/registry/mini-app/lib/utils\"\n\nconst sheetVariants = cva(\n  \"fixed z-50 gap-4 bg-background p-6 shadow-lg transition-all duration-300 ease-in-out border rounded-lg\",\n  {\n    variants: {\n      side: {\n        top: \"inset-x-4 top-4 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top\",\n        bottom: \"inset-x-4 bottom-4 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom\",\n        left: \"inset-y-4 left-4 w-3/4 max-w-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left\",\n        right: \"inset-y-4 right-4 w-3/4 max-w-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right\",\n      },\n    },\n    defaultVariants: {\n      side: \"bottom\",\n    },\n  }\n)\n\ninterface SheetProps {\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n  children: React.ReactNode\n}\n\ninterface SheetContentProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof sheetVariants> {\n  onClose?: () => void\n}\n\nconst SheetContext = React.createContext<{\n  open: boolean\n  onOpenChange: (open: boolean) => void\n}>({\n  open: false,\n  onOpenChange: () => {},\n})\n\nexport function Sheet({ open = false, onOpenChange, children }: SheetProps) {\n  return (\n    <SheetContext.Provider value={{ open, onOpenChange: onOpenChange || (() => {}) }}>\n      {children}\n    </SheetContext.Provider>\n  )\n}\n\nexport function SheetTrigger({ \n  children, \n  onClick,\n  ...props \n}: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n  const { onOpenChange } = React.useContext(SheetContext)\n  \n  return (\n    <button\n      onClick={(e) => {\n        onOpenChange(true)\n        onClick?.(e)\n      }}\n      {...props}\n    >\n      {children}\n    </button>\n  )\n}\n\nexport function SheetContent({ \n  side = \"bottom\", \n  className, \n  children, \n  onClose,\n  ...props \n}: SheetContentProps) {\n  const { open, onOpenChange } = React.useContext(SheetContext)\n\n  const handleClose = () => {\n    onOpenChange(false)\n    onClose?.()\n  }\n\n  React.useEffect(() => {\n    const handleEscape = (e: KeyboardEvent) => {\n      if (e.key === \"Escape\" && open) {\n        handleClose()\n      }\n    }\n\n    if (open) {\n      document.addEventListener(\"keydown\", handleEscape)\n      document.body.style.overflow = \"hidden\"\n    }\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleEscape)\n      document.body.style.overflow = \"unset\"\n    }\n  }, [open])\n\n  if (!open) return null\n\n  return (\n    <>\n      {/* Backdrop */}\n      <div \n        className=\"fixed inset-0 bg-black/50 backdrop-blur-sm z-40\"\n        onClick={handleClose}\n      />\n      \n      {/* Sheet Content */}\n      <div\n        className={cn(sheetVariants({ side }), className)}\n        data-state={open ? \"open\" : \"closed\"}\n        {...props}\n      >\n        {children}\n        <button\n          onClick={handleClose}\n          className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none p-1\"\n        >\n          <X className=\"h-4 w-4\" />\n          <span className=\"sr-only\">Close</span>\n        </button>\n      </div>\n    </>\n  )\n}\n\nexport function SheetClose({ \n  children, \n  onClick,\n  ...props \n}: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n  const { onOpenChange } = React.useContext(SheetContext)\n  \n  return (\n    <button\n      onClick={(e) => {\n        onOpenChange(false)\n        onClick?.(e)\n      }}\n      {...props}\n    >\n      {children}\n    </button>\n  )\n}\n\nexport function SheetHeader({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\n        \"flex flex-col space-y-2 text-center sm:text-left\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport function SheetFooter({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\n        \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport function SheetTitle({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLHeadingElement>) {\n  return (\n    <h2\n      className={cn(\"text-lg font-semibold text-foreground\", className)}\n      {...props}\n    />\n  )\n}\n\nexport function SheetDescription({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLParagraphElement>) {\n  return (\n    <p\n      className={cn(\"text-sm text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n} ",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "registry/mini-app/hooks/use-miniapp-sdk.ts",
      "content": "\"use client\";\n\nimport { useCallback, useEffect, useState } from \"react\";\nimport sdk from \"@farcaster/frame-sdk\";\nimport type { Context } from \"@farcaster/frame-core\";\n\nexport function useMiniAppSdk() {\n  const [isAuthDialogOpen, setIsAuthDialogOpen] = useState(false);\n\n  const [isSDKLoaded, setIsSDKLoaded] = useState(false);\n  const [context, setContext] = useState<Context.FrameContext>();\n  const [isMiniAppSaved, setIsMiniAppSaved] = useState(false);\n  const [lastEvent, setLastEvent] = useState(\"\");\n  const [pinFrameResponse, setPinFrameResponse] = useState(\"\");\n  const [isMiniApp, setIsMiniApp] = useState(false);\n\n  useEffect(() => {\n    if (!sdk) return;\n\n    sdk.on(\"frameAdded\", ({ notificationDetails }) => {\n      setLastEvent(\n        `frameAdded${notificationDetails ? \", notifications enabled\" : \"\"}`,\n      );\n      setIsMiniAppSaved(true);\n    });\n\n    sdk.on(\"frameAddRejected\", ({ reason }) => {\n      setLastEvent(`frameAddRejected, reason ${reason}`);\n    });\n\n    sdk.on(\"frameRemoved\", () => {\n      setLastEvent(\"frameRemoved\");\n      setIsMiniAppSaved(false);\n    });\n\n    sdk.on(\"notificationsEnabled\", ({ notificationDetails }) => {\n      setLastEvent(\"notificationsEnabled\");\n    });\n\n    sdk.on(\"notificationsDisabled\", () => {\n      setLastEvent(\"notificationsDisabled\");\n    });\n\n    // CRITICAL TO LOAD MINI APP - DON'T REMOVE\n    sdk.actions.ready({});\n    setIsSDKLoaded(true);\n\n    // Clean up on unmount\n    return () => {\n      sdk.removeAllListeners();\n    };\n  }, []);\n\n  useEffect(() => {\n    const updateContext = async () => {\n      const frameContext = await sdk.context;\n      if (frameContext) {\n        setContext(frameContext);\n        setIsMiniAppSaved(frameContext.client.added);\n      }\n\n      const miniAppStatus = await sdk.isInMiniApp();\n      setIsMiniApp(miniAppStatus);\n    };\n\n    if (isSDKLoaded) {\n      updateContext();\n    }\n  }, [isSDKLoaded]);\n\n  const pinFrame = useCallback(async () => {\n    try {\n      const result = await sdk.actions.addFrame();\n      console.log(\"addFrame result\", result);\n      // @ts-expect-error - result type mixup\n      if (result.added) {\n        setPinFrameResponse(\n          result.notificationDetails\n            ? `Added, got notificaton token ${result.notificationDetails.token} and url ${result.notificationDetails.url}`\n            : \"Added, got no notification details\",\n        );\n      }\n    } catch (error) {\n      setPinFrameResponse(`Error: ${error}`);\n    }\n  }, []);\n\n  return {\n    context,\n    pinFrame,\n    pinFrameResponse,\n    isMiniAppSaved,\n    lastEvent,\n    sdk,\n    isSDKLoaded,\n    isAuthDialogOpen,\n    setIsAuthDialogOpen,\n    isMiniApp,\n  };\n}\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}