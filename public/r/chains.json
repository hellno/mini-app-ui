{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "chains",
  "type": "registry:lib",
  "title": "chains",
  "description": "Centralized chain configuration with Alchemy RPC support",
  "dependencies": [
    "viem"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/mini-app/lib/chains.ts",
      "content": "import { http, type Chain, type PublicClient, createPublicClient } from \"viem\";\nimport * as chains from \"viem/chains\";\n\n/**\n * Centralized chain configuration with Alchemy RPC support\n * Maps chain IDs to their Alchemy subdomain prefixes\n */\nexport const ALCHEMY_CHAIN_CONFIGS: Record<number, { name: string; url: string | null }> = {\n  1: { name: 'ethereum', url: 'eth-mainnet' },\n  10: { name: 'optimism', url: 'opt-mainnet' },\n  137: { name: 'polygon', url: 'polygon-mainnet' },\n  8453: { name: 'base', url: 'base-mainnet' },\n  42161: { name: 'arbitrum', url: 'arb-mainnet' },\n  7777777: { name: 'zora', url: null }, // No Alchemy support\n} as const;\n\n/**\n * Get viem Chain object by ID\n */\nexport function getChainById(chainId: number): Chain {\n  switch (chainId) {\n    case 1:\n      return chains.mainnet;\n    case 10:\n      return chains.optimism;\n    case 137:\n      return chains.polygon;\n    case 8453:\n      return chains.base;\n    case 42161:\n      return chains.arbitrum;\n    case 7777777:\n      return chains.zora;\n    default:\n      // Try to find in all chains\n      const chain = Object.values(chains).find(\n        (c): c is Chain => typeof c === 'object' && c !== null && 'id' in c && c.id === chainId\n      );\n      return chain || chains.mainnet;\n  }\n}\n\n/**\n * Get HTTP transport with optional Alchemy RPC URL\n * Falls back to public RPC if no Alchemy key is available\n */\nexport function getTransport(chainId: number) {\n  const alchemyKey = process.env.NEXT_PUBLIC_ALCHEMY_KEY;\n  const config = ALCHEMY_CHAIN_CONFIGS[chainId];\n  \n  if (config?.url && alchemyKey) {\n    return http(`https://${config.url}.g.alchemy.com/v2/${alchemyKey}`);\n  }\n  \n  // Fallback to default public RPC\n  return http();\n}\n\n/**\n * Create a public client for a specific chain with optimal transport\n */\nexport function getPublicClient(chainId: number): PublicClient {\n  return createPublicClient({\n    chain: getChainById(chainId),\n    transport: getTransport(chainId),\n  }) as PublicClient;\n}\n\n/**\n * Get all available chains mapped by normalized name\n */\nexport function getAvailableChains(): Record<string, Chain> {\n  const availableChains: Record<string, Chain> = {};\n  \n  Object.entries(chains).forEach(([name, chain]) => {\n    if (typeof chain === \"object\" && chain !== null && \"id\" in chain) {\n      availableChains[name.toLowerCase()] = chain as Chain;\n    }\n  });\n  \n  return availableChains;\n}\n\n/**\n * Find chain by network name (fuzzy match)\n */\nexport function findChainByName(networkName: string): Chain | undefined {\n  const normalizedName = networkName.toLowerCase().replace(/[\\s-]/g, \"\");\n  const availableChains = getAvailableChains();\n  \n  // Try exact match first\n  if (availableChains[normalizedName]) {\n    return availableChains[normalizedName];\n  }\n  \n  // Try partial match\n  const matchingChainName = Object.keys(availableChains).find(\n    (chainName) =>\n      chainName.includes(normalizedName) ||\n      normalizedName.includes(chainName)\n  );\n  \n  return matchingChainName ? availableChains[matchingChainName] : undefined;\n}",
      "type": "registry:lib"
    }
  ]
}