{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "nft-card",
  "type": "registry:component",
  "title": "NFT Card",
  "description": "A versatile NFT display component that supports multiple blockchains with rich metadata and custom styling options",
  "dependencies": [
    "viem",
    "next/image",
    "clsx",
    "tailwind-merge",
    "viem"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/mini-app/blocks/nft-card/nft-card.tsx",
      "content": "\"use client\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\nimport Image from \"next/image\";\r\nimport { useState, useEffect } from \"react\";\r\n\r\ninterface NFTMetadata {\r\n  name?: string;\r\n  description?: string;\r\n  image?: string;\r\n  external_url?: string;\r\n  attributes?: Array<{\r\n    trait_type: string;\r\n    value: string | number;\r\n    display_type?: string;\r\n  }>;\r\n  [key: string]: unknown;\r\n}\r\nimport { createPublicClient, http, parseAbi, getAddress, Chain } from \"viem\";\r\nimport * as chains from \"viem/chains\";\r\n\r\n// Base64 placeholder image\r\nconst PLACEHOLDER_IMAGE = \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgZmlsbD0iI2YxZjFmMSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjQiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiIGZpbGw9IiM5OTkiPk5GVCBJbWFnZTwvdGV4dD48L3N2Zz4=\";\r\n\r\n// ERC721 ABI for tokenURI and name functions\r\nconst erc721Abi = parseAbi([\r\n  'function tokenURI(uint256 tokenId) view returns (string)',\r\n  'function name() view returns (string)',\r\n  'function symbol() view returns (string)',\r\n  'function ownerOf(uint256 tokenId) view returns (address)'\r\n]);\r\n\r\n// Get all available chains from viem\r\nconst availableChains: Record<string, Chain> = {};\r\nObject.entries(chains).forEach(([name, chain]) => {\r\n  if (typeof chain === 'object' && chain !== null && 'id' in chain) {\r\n    availableChains[name.toLowerCase()] = chain as Chain;\r\n  }\r\n});\r\n\r\ntype NFTCardProps = {\r\n  contractAddress: string;\r\n  tokenId: string;\r\n  network?: string;\r\n  alt?: string;\r\n  className?: string;\r\n  width?: number;\r\n  height?: number;\r\n  rounded?: \"none\" | \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\r\n  shadow?: boolean;\r\n  objectFit?: \"contain\" | \"cover\" | \"fill\";\r\n  fallbackImageUrl?: string;\r\n  showTitle?: boolean;\r\n  showNetwork?: boolean;\r\n  titlePosition?: \"top\" | \"bottom\" | \"outside\";\r\n  networkPosition?: \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\" | \"outside\";\r\n  customTitle?: string;\r\n  customNetworkName?: string;\r\n  loadingComponent?: React.ReactNode;\r\n  errorComponent?: React.ReactNode;\r\n  imageProps?: React.ComponentProps<typeof Image>;\r\n  titleClassName?: string;\r\n  networkClassName?: string;\r\n  showOwner?: boolean;\r\n  onLoad?: (metadata: NFTMetadata) => void;\r\n  onError?: (error: Error) => void;\r\n  layout?: \"compact\" | \"card\" | \"detailed\";\r\n  containerClassName?: string;\r\n};\r\n\r\nexport function NFTCard({\r\n  contractAddress,\r\n  tokenId,\r\n  network = \"ethereum\", // Default to Ethereum mainnet\r\n  alt = \"NFT Image\",\r\n  className = \"\",\r\n  width = 300,\r\n  height = 300,\r\n  rounded = \"md\",\r\n  shadow = true,\r\n  objectFit = \"cover\",\r\n  fallbackImageUrl = PLACEHOLDER_IMAGE,\r\n  showTitle = true,\r\n  showNetwork = true,\r\n  titlePosition = \"outside\",\r\n  networkPosition = \"top-right\",\r\n  customTitle,\r\n  customNetworkName,\r\n  loadingComponent,\r\n  errorComponent,\r\n  imageProps,\r\n  titleClassName = \"\",\r\n  networkClassName = \"\",\r\n  showOwner = false,\r\n  onLoad,\r\n  onError,\r\n  layout = \"card\",\r\n  containerClassName = \"\",\r\n}: NFTCardProps) {\r\n  const [imageUrl, setImageUrl] = useState<string>(fallbackImageUrl);\r\n  const [isLoading, setIsLoading] = useState<boolean>(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [title, setTitle] = useState<string | null>(customTitle || null);\r\n  const [networkName, setNetworkName] = useState<string>(customNetworkName || \"\");\r\n  const [owner, setOwner] = useState<string | null>(null);\r\n\r\n  const roundedClasses = {\r\n    none: \"rounded-none\",\r\n    sm: \"rounded-sm\",\r\n    md: \"rounded-md\",\r\n    lg: \"rounded-lg\",\r\n    xl: \"rounded-xl\",\r\n    full: \"rounded-full\"\r\n  };\r\n\r\n  const networkPositionClasses = {\r\n    \"top-left\": \"top-0 left-0 rounded-br-md\",\r\n    \"top-right\": \"top-0 right-0 rounded-bl-md\",\r\n    \"bottom-left\": \"bottom-0 left-0 rounded-tr-md\",\r\n    \"bottom-right\": \"bottom-0 right-0 rounded-tl-md\",\r\n    \"outside\": \"\"\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (customTitle) {\r\n      setTitle(customTitle);\r\n    }\r\n    \r\n    if (customNetworkName) {\r\n      setNetworkName(customNetworkName);\r\n    }\r\n  }, [customTitle, customNetworkName]);\r\n\r\n  useEffect(() => {\r\n    const fetchNFTData = async () => {\r\n      if (!contractAddress || !tokenId) return;\r\n      \r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      try {\r\n        // Skip chain setup if we have customNetworkName\r\n        if (!customNetworkName) {\r\n          // Normalize network name\r\n          const normalizedNetwork = (network || \"ethereum\").toLowerCase().replace(/[\\s-]/g, '');\r\n          \r\n          // Find the chain by name\r\n          let selectedChain: Chain | undefined;\r\n          \r\n          // Try to find exact match first\r\n          if (availableChains[normalizedNetwork]) {\r\n            selectedChain = availableChains[normalizedNetwork];\r\n          } else {\r\n            // Try to find partial match\r\n            const matchingChainName = Object.keys(availableChains).find(\r\n              chainName => chainName.includes(normalizedNetwork) || normalizedNetwork.includes(chainName)\r\n            );\r\n            \r\n            if (matchingChainName) {\r\n              selectedChain = availableChains[matchingChainName];\r\n            }\r\n          }\r\n          \r\n          // Default to mainnet if no match found\r\n          if (!selectedChain) {\r\n            console.warn(`Chain \"${network}\" not found, defaulting to Ethereum mainnet`);\r\n            selectedChain = chains.mainnet;\r\n            setNetworkName(\"Ethereum\");\r\n          } else {\r\n            setNetworkName(selectedChain.name);\r\n          }\r\n          \r\n          // Create public client for the selected chain\r\n          const client = createPublicClient({\r\n            chain: selectedChain,\r\n            transport: http(),\r\n          });\r\n\r\n          console.log(`Fetching NFT data from ${selectedChain.name} for contract ${contractAddress} token ${tokenId}`);\r\n\r\n          // Skip title setup if we have customTitle\r\n          if (!customTitle) {\r\n            try {\r\n              // Get contract name\r\n              const name = await client.readContract({\r\n                address: getAddress(contractAddress),\r\n                abi: erc721Abi,\r\n                functionName: 'name',\r\n              }) as string;\r\n              \r\n              // Set title\r\n              setTitle(`${name} #${tokenId}`);\r\n            } catch (nameError) {\r\n              console.warn(\"Could not fetch NFT name:\", nameError);\r\n              setTitle(`NFT #${tokenId}`);\r\n            }\r\n          }\r\n\r\n          // Get owner if requested\r\n          if (showOwner) {\r\n            try {\r\n              const ownerAddress = await client.readContract({\r\n                address: getAddress(contractAddress),\r\n                abi: erc721Abi,\r\n                functionName: 'ownerOf',\r\n                args: [BigInt(tokenId)],\r\n              }) as string;\r\n              \r\n              setOwner(ownerAddress);\r\n            } catch (ownerError) {\r\n              console.warn(\"Could not fetch NFT owner:\", ownerError);\r\n            }\r\n          }\r\n\r\n          // Get tokenURI\r\n          const tokenURI = await client.readContract({\r\n            address: getAddress(contractAddress),\r\n            abi: erc721Abi,\r\n            functionName: 'tokenURI',\r\n            args: [BigInt(tokenId)],\r\n          }) as string;\r\n\r\n          // Process tokenURI to get metadata\r\n          let metadataUrl = tokenURI;\r\n          \r\n          // Handle IPFS URLs\r\n          if (metadataUrl.startsWith('ipfs://')) {\r\n            metadataUrl = metadataUrl.replace('ipfs://', 'https://ipfs.io/ipfs/');\r\n          }\r\n          \r\n          // Fetch metadata\r\n          const metadata = await fetch(metadataUrl).then(res => res.json());\r\n          console.log(\"NFT metadata:\", metadata);\r\n          \r\n          // Call onLoad callback if provided\r\n          if (onLoad) {\r\n            onLoad(metadata);\r\n          }\r\n          \r\n          // Get image URL from metadata\r\n          let nftImageUrl = metadata.image;\r\n          \r\n          // Handle IPFS URLs for image\r\n          if (nftImageUrl && nftImageUrl.startsWith('ipfs://')) {\r\n            nftImageUrl = nftImageUrl.replace('ipfs://', 'https://ipfs.io/ipfs/');\r\n          }\r\n\r\n          if (nftImageUrl) {\r\n            setImageUrl(nftImageUrl);\r\n          } else {\r\n            // If no image URL found, use placeholder\r\n            setImageUrl(fallbackImageUrl);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.error(\"Error fetching NFT:\", err);\r\n        const error = err instanceof Error ? err : new Error(String(err));\r\n        setError(`Failed to load NFT data: ${error.message}`);\r\n        setImageUrl(fallbackImageUrl);\r\n        \r\n        // Call onError callback if provided\r\n        if (onError) {\r\n          onError(error);\r\n        }\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchNFTData();\r\n  }, [contractAddress, tokenId, network, fallbackImageUrl, customTitle, customNetworkName, showOwner, onLoad, onError]);\r\n\r\n  const defaultLoadingComponent = (\r\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800\">\r\n      <div className=\"animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary\"></div>\r\n    </div>\r\n  );\r\n\r\n  const defaultErrorComponent = (\r\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800\">\r\n      <p className=\"text-red-500 text-sm text-center px-2\">{error}</p>\r\n    </div>\r\n  );\r\n\r\n  // Render network badge inside the image\r\n  const renderNetworkBadge = () => {\r\n    if (!showNetwork || !networkName || networkPosition === \"outside\") return null;\r\n    \r\n    return (\r\n      <div \r\n        className={cn(\r\n          \"absolute bg-black/60 px-2 py-1 text-white text-xs\",\r\n          networkPositionClasses[networkPosition],\r\n          networkClassName\r\n        )}\r\n      >\r\n        {networkName}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // Render title inside the image\r\n  const renderInnerTitle = () => {\r\n    if (!showTitle || !title || titlePosition === \"outside\") return null;\r\n    \r\n    return (\r\n      <div \r\n        className={cn(\r\n          \"absolute left-0 right-0 bg-black/60 p-2 text-white text-sm truncate\",\r\n          titlePosition === \"top\" ? \"top-0\" : \"bottom-0\",\r\n          titleClassName\r\n        )}\r\n      >\r\n        {title}\r\n        {showOwner && owner && (\r\n          <div className=\"text-xs opacity-70 truncate\">\r\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\r\n          </div>\r\n        )}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // Render outside information (title, network, owner)\r\n  const renderOutsideInfo = () => {\r\n    if (\r\n      (!showTitle || !title) && \r\n      (!showNetwork || !networkName || networkPosition !== \"outside\") && \r\n      (!showOwner || !owner || titlePosition !== \"outside\")\r\n    ) {\r\n      return null;\r\n    }\r\n\r\n    return (\r\n      <div className=\"mt-2\">\r\n        {showTitle && title && titlePosition === \"outside\" && (\r\n          <div className={cn(\"text-sm font-medium truncate\", titleClassName)}>\r\n            {title}\r\n          </div>\r\n        )}\r\n        \r\n        {showNetwork && networkName && networkPosition === \"outside\" && (\r\n          <div className={cn(\"text-xs text-gray-500 dark:text-gray-400\", networkClassName)}>\r\n            Network: {networkName}\r\n          </div>\r\n        )}\r\n        \r\n        {showOwner && owner && titlePosition === \"outside\" && (\r\n          <div className=\"text-xs text-gray-500 dark:text-gray-400 truncate\">\r\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\r\n          </div>\r\n        )}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // Apply different layouts\r\n  const getContainerClasses = () => {\r\n    switch (layout) {\r\n      case \"compact\":\r\n        return \"inline-block\";\r\n      case \"detailed\":\r\n        return \"flex flex-col overflow-hidden\";\r\n      case \"card\":\r\n      default:\r\n        return \"\";\r\n    }\r\n  };\r\n\r\n  // Create CSS class for width and height\r\n  // Dimension classes will be applied via className\r\n\r\n  return (\r\n    <div className={cn(getContainerClasses(), containerClassName)}>\r\n      <div \r\n        className={cn(\r\n          \"relative overflow-hidden\",\r\n          roundedClasses[rounded],\r\n          shadow && \"shadow-md\",\r\n          className\r\n        )}\r\n        style={{ width: `${width}px`, height: `${height}px` }} // Using style prop as a last resort for dynamic dimensions\r\n      >\r\n        {isLoading && (loadingComponent || defaultLoadingComponent)}\r\n        \r\n        {error && (errorComponent || defaultErrorComponent)}\r\n        \r\n        <Image \r\n          src={imageUrl}\r\n          alt={alt}\r\n          fill={true}\r\n          className={cn(\r\n            \"object-\" + objectFit,\r\n            isLoading && \"opacity-0\"\r\n          )}\r\n          unoptimized={true}\r\n          onError={() => setImageUrl(PLACEHOLDER_IMAGE)}\r\n          {...imageProps}\r\n        />\r\n        \r\n        {renderInnerTitle()}\r\n        {renderNetworkBadge()}\r\n      </div>\r\n      \r\n      {renderOutsideInfo()}\r\n    </div>\r\n  );\r\n} ",
      "type": "registry:component"
    },
    {
      "path": "registry\\mini-app\\blocks\\nft-card\\nft-card.tsx",
      "content": "\"use client\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\nimport Image from \"next/image\";\r\nimport { useState, useEffect } from \"react\";\r\n\r\ninterface NFTMetadata {\r\n  name?: string;\r\n  description?: string;\r\n  image?: string;\r\n  external_url?: string;\r\n  attributes?: Array<{\r\n    trait_type: string;\r\n    value: string | number;\r\n    display_type?: string;\r\n  }>;\r\n  [key: string]: unknown;\r\n}\r\nimport { createPublicClient, http, parseAbi, getAddress, Chain } from \"viem\";\r\nimport * as chains from \"viem/chains\";\r\n\r\n// Base64 placeholder image\r\nconst PLACEHOLDER_IMAGE = \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgZmlsbD0iI2YxZjFmMSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjQiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiIGZpbGw9IiM5OTkiPk5GVCBJbWFnZTwvdGV4dD48L3N2Zz4=\";\r\n\r\n// ERC721 ABI for tokenURI and name functions\r\nconst erc721Abi = parseAbi([\r\n  'function tokenURI(uint256 tokenId) view returns (string)',\r\n  'function name() view returns (string)',\r\n  'function symbol() view returns (string)',\r\n  'function ownerOf(uint256 tokenId) view returns (address)'\r\n]);\r\n\r\n// Get all available chains from viem\r\nconst availableChains: Record<string, Chain> = {};\r\nObject.entries(chains).forEach(([name, chain]) => {\r\n  if (typeof chain === 'object' && chain !== null && 'id' in chain) {\r\n    availableChains[name.toLowerCase()] = chain as Chain;\r\n  }\r\n});\r\n\r\ntype NFTCardProps = {\r\n  contractAddress: string;\r\n  tokenId: string;\r\n  network?: string;\r\n  alt?: string;\r\n  className?: string;\r\n  width?: number;\r\n  height?: number;\r\n  rounded?: \"none\" | \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\r\n  shadow?: boolean;\r\n  objectFit?: \"contain\" | \"cover\" | \"fill\";\r\n  fallbackImageUrl?: string;\r\n  showTitle?: boolean;\r\n  showNetwork?: boolean;\r\n  titlePosition?: \"top\" | \"bottom\" | \"outside\";\r\n  networkPosition?: \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\" | \"outside\";\r\n  customTitle?: string;\r\n  customNetworkName?: string;\r\n  loadingComponent?: React.ReactNode;\r\n  errorComponent?: React.ReactNode;\r\n  imageProps?: React.ComponentProps<typeof Image>;\r\n  titleClassName?: string;\r\n  networkClassName?: string;\r\n  showOwner?: boolean;\r\n  onLoad?: (metadata: NFTMetadata) => void;\r\n  onError?: (error: Error) => void;\r\n  layout?: \"compact\" | \"card\" | \"detailed\";\r\n  containerClassName?: string;\r\n};\r\n\r\nexport function NFTCard({\r\n  contractAddress,\r\n  tokenId,\r\n  network = \"ethereum\", // Default to Ethereum mainnet\r\n  alt = \"NFT Image\",\r\n  className = \"\",\r\n  width = 300,\r\n  height = 300,\r\n  rounded = \"md\",\r\n  shadow = true,\r\n  objectFit = \"cover\",\r\n  fallbackImageUrl = PLACEHOLDER_IMAGE,\r\n  showTitle = true,\r\n  showNetwork = true,\r\n  titlePosition = \"outside\",\r\n  networkPosition = \"top-right\",\r\n  customTitle,\r\n  customNetworkName,\r\n  loadingComponent,\r\n  errorComponent,\r\n  imageProps,\r\n  titleClassName = \"\",\r\n  networkClassName = \"\",\r\n  showOwner = false,\r\n  onLoad,\r\n  onError,\r\n  layout = \"card\",\r\n  containerClassName = \"\",\r\n}: NFTCardProps) {\r\n  const [imageUrl, setImageUrl] = useState<string>(fallbackImageUrl);\r\n  const [isLoading, setIsLoading] = useState<boolean>(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [title, setTitle] = useState<string | null>(customTitle || null);\r\n  const [networkName, setNetworkName] = useState<string>(customNetworkName || \"\");\r\n  const [owner, setOwner] = useState<string | null>(null);\r\n\r\n  const roundedClasses = {\r\n    none: \"rounded-none\",\r\n    sm: \"rounded-sm\",\r\n    md: \"rounded-md\",\r\n    lg: \"rounded-lg\",\r\n    xl: \"rounded-xl\",\r\n    full: \"rounded-full\"\r\n  };\r\n\r\n  const networkPositionClasses = {\r\n    \"top-left\": \"top-0 left-0 rounded-br-md\",\r\n    \"top-right\": \"top-0 right-0 rounded-bl-md\",\r\n    \"bottom-left\": \"bottom-0 left-0 rounded-tr-md\",\r\n    \"bottom-right\": \"bottom-0 right-0 rounded-tl-md\",\r\n    \"outside\": \"\"\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (customTitle) {\r\n      setTitle(customTitle);\r\n    }\r\n    \r\n    if (customNetworkName) {\r\n      setNetworkName(customNetworkName);\r\n    }\r\n  }, [customTitle, customNetworkName]);\r\n\r\n  useEffect(() => {\r\n    const fetchNFTData = async () => {\r\n      if (!contractAddress || !tokenId) return;\r\n      \r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      try {\r\n        // Skip chain setup if we have customNetworkName\r\n        if (!customNetworkName) {\r\n          // Normalize network name\r\n          const normalizedNetwork = (network || \"ethereum\").toLowerCase().replace(/[\\s-]/g, '');\r\n          \r\n          // Find the chain by name\r\n          let selectedChain: Chain | undefined;\r\n          \r\n          // Try to find exact match first\r\n          if (availableChains[normalizedNetwork]) {\r\n            selectedChain = availableChains[normalizedNetwork];\r\n          } else {\r\n            // Try to find partial match\r\n            const matchingChainName = Object.keys(availableChains).find(\r\n              chainName => chainName.includes(normalizedNetwork) || normalizedNetwork.includes(chainName)\r\n            );\r\n            \r\n            if (matchingChainName) {\r\n              selectedChain = availableChains[matchingChainName];\r\n            }\r\n          }\r\n          \r\n          // Default to mainnet if no match found\r\n          if (!selectedChain) {\r\n            console.warn(`Chain \"${network}\" not found, defaulting to Ethereum mainnet`);\r\n            selectedChain = chains.mainnet;\r\n            setNetworkName(\"Ethereum\");\r\n          } else {\r\n            setNetworkName(selectedChain.name);\r\n          }\r\n          \r\n          // Create public client for the selected chain\r\n          const client = createPublicClient({\r\n            chain: selectedChain,\r\n            transport: http(),\r\n          });\r\n\r\n          console.log(`Fetching NFT data from ${selectedChain.name} for contract ${contractAddress} token ${tokenId}`);\r\n\r\n          // Skip title setup if we have customTitle\r\n          if (!customTitle) {\r\n            try {\r\n              // Get contract name\r\n              const name = await client.readContract({\r\n                address: getAddress(contractAddress),\r\n                abi: erc721Abi,\r\n                functionName: 'name',\r\n              }) as string;\r\n              \r\n              // Set title\r\n              setTitle(`${name} #${tokenId}`);\r\n            } catch (nameError) {\r\n              console.warn(\"Could not fetch NFT name:\", nameError);\r\n              setTitle(`NFT #${tokenId}`);\r\n            }\r\n          }\r\n\r\n          // Get owner if requested\r\n          if (showOwner) {\r\n            try {\r\n              const ownerAddress = await client.readContract({\r\n                address: getAddress(contractAddress),\r\n                abi: erc721Abi,\r\n                functionName: 'ownerOf',\r\n                args: [BigInt(tokenId)],\r\n              }) as string;\r\n              \r\n              setOwner(ownerAddress);\r\n            } catch (ownerError) {\r\n              console.warn(\"Could not fetch NFT owner:\", ownerError);\r\n            }\r\n          }\r\n\r\n          // Get tokenURI\r\n          const tokenURI = await client.readContract({\r\n            address: getAddress(contractAddress),\r\n            abi: erc721Abi,\r\n            functionName: 'tokenURI',\r\n            args: [BigInt(tokenId)],\r\n          }) as string;\r\n\r\n          // Process tokenURI to get metadata\r\n          let metadataUrl = tokenURI;\r\n          \r\n          // Handle IPFS URLs\r\n          if (metadataUrl.startsWith('ipfs://')) {\r\n            metadataUrl = metadataUrl.replace('ipfs://', 'https://ipfs.io/ipfs/');\r\n          }\r\n          \r\n          // Fetch metadata\r\n          const metadata = await fetch(metadataUrl).then(res => res.json());\r\n          console.log(\"NFT metadata:\", metadata);\r\n          \r\n          // Call onLoad callback if provided\r\n          if (onLoad) {\r\n            onLoad(metadata);\r\n          }\r\n          \r\n          // Get image URL from metadata\r\n          let nftImageUrl = metadata.image;\r\n          \r\n          // Handle IPFS URLs for image\r\n          if (nftImageUrl && nftImageUrl.startsWith('ipfs://')) {\r\n            nftImageUrl = nftImageUrl.replace('ipfs://', 'https://ipfs.io/ipfs/');\r\n          }\r\n\r\n          if (nftImageUrl) {\r\n            setImageUrl(nftImageUrl);\r\n          } else {\r\n            // If no image URL found, use placeholder\r\n            setImageUrl(fallbackImageUrl);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.error(\"Error fetching NFT:\", err);\r\n        const error = err instanceof Error ? err : new Error(String(err));\r\n        setError(`Failed to load NFT data: ${error.message}`);\r\n        setImageUrl(fallbackImageUrl);\r\n        \r\n        // Call onError callback if provided\r\n        if (onError) {\r\n          onError(error);\r\n        }\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchNFTData();\r\n  }, [contractAddress, tokenId, network, fallbackImageUrl, customTitle, customNetworkName, showOwner, onLoad, onError]);\r\n\r\n  const defaultLoadingComponent = (\r\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800\">\r\n      <div className=\"animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary\"></div>\r\n    </div>\r\n  );\r\n\r\n  const defaultErrorComponent = (\r\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800\">\r\n      <p className=\"text-red-500 text-sm text-center px-2\">{error}</p>\r\n    </div>\r\n  );\r\n\r\n  // Render network badge inside the image\r\n  const renderNetworkBadge = () => {\r\n    if (!showNetwork || !networkName || networkPosition === \"outside\") return null;\r\n    \r\n    return (\r\n      <div \r\n        className={cn(\r\n          \"absolute bg-black/60 px-2 py-1 text-white text-xs\",\r\n          networkPositionClasses[networkPosition],\r\n          networkClassName\r\n        )}\r\n      >\r\n        {networkName}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // Render title inside the image\r\n  const renderInnerTitle = () => {\r\n    if (!showTitle || !title || titlePosition === \"outside\") return null;\r\n    \r\n    return (\r\n      <div \r\n        className={cn(\r\n          \"absolute left-0 right-0 bg-black/60 p-2 text-white text-sm truncate\",\r\n          titlePosition === \"top\" ? \"top-0\" : \"bottom-0\",\r\n          titleClassName\r\n        )}\r\n      >\r\n        {title}\r\n        {showOwner && owner && (\r\n          <div className=\"text-xs opacity-70 truncate\">\r\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\r\n          </div>\r\n        )}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // Render outside information (title, network, owner)\r\n  const renderOutsideInfo = () => {\r\n    if (\r\n      (!showTitle || !title) && \r\n      (!showNetwork || !networkName || networkPosition !== \"outside\") && \r\n      (!showOwner || !owner || titlePosition !== \"outside\")\r\n    ) {\r\n      return null;\r\n    }\r\n\r\n    return (\r\n      <div className=\"mt-2\">\r\n        {showTitle && title && titlePosition === \"outside\" && (\r\n          <div className={cn(\"text-sm font-medium truncate\", titleClassName)}>\r\n            {title}\r\n          </div>\r\n        )}\r\n        \r\n        {showNetwork && networkName && networkPosition === \"outside\" && (\r\n          <div className={cn(\"text-xs text-gray-500 dark:text-gray-400\", networkClassName)}>\r\n            Network: {networkName}\r\n          </div>\r\n        )}\r\n        \r\n        {showOwner && owner && titlePosition === \"outside\" && (\r\n          <div className=\"text-xs text-gray-500 dark:text-gray-400 truncate\">\r\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\r\n          </div>\r\n        )}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // Apply different layouts\r\n  const getContainerClasses = () => {\r\n    switch (layout) {\r\n      case \"compact\":\r\n        return \"inline-block\";\r\n      case \"detailed\":\r\n        return \"flex flex-col overflow-hidden\";\r\n      case \"card\":\r\n      default:\r\n        return \"\";\r\n    }\r\n  };\r\n\r\n  // Create CSS class for width and height\r\n  // Dimension classes will be applied via className\r\n\r\n  return (\r\n    <div className={cn(getContainerClasses(), containerClassName)}>\r\n      <div \r\n        className={cn(\r\n          \"relative overflow-hidden\",\r\n          roundedClasses[rounded],\r\n          shadow && \"shadow-md\",\r\n          className\r\n        )}\r\n        style={{ width: `${width}px`, height: `${height}px` }} // Using style prop as a last resort for dynamic dimensions\r\n      >\r\n        {isLoading && (loadingComponent || defaultLoadingComponent)}\r\n        \r\n        {error && (errorComponent || defaultErrorComponent)}\r\n        \r\n        <Image \r\n          src={imageUrl}\r\n          alt={alt}\r\n          fill={true}\r\n          className={cn(\r\n            \"object-\" + objectFit,\r\n            isLoading && \"opacity-0\"\r\n          )}\r\n          unoptimized={true}\r\n          onError={() => setImageUrl(PLACEHOLDER_IMAGE)}\r\n          {...imageProps}\r\n        />\r\n        \r\n        {renderInnerTitle()}\r\n        {renderNetworkBadge()}\r\n      </div>\r\n      \r\n      {renderOutsideInfo()}\r\n    </div>\r\n  );\r\n} ",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib\\utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\";\r\nimport { twMerge } from \"tailwind-merge\";\r\n\r\nexport function cn(...inputs: ClassValue[]) {\r\n  return twMerge(clsx(inputs));\r\n}\r\n\r\n\r\nexport const formatLargeNumber = (num?: number): string => {\r\n  if (!num) return '0';\r\n\r\n  if (num >= 1000000) {\r\n    return (num / 1000000).toFixed(1) + 'M';\r\n  } else if (num >= 2000) {\r\n    return (num / 1000).toFixed(1) + 'K';\r\n  } else {\r\n    return num.toString();\r\n  }\r\n};",
      "type": "registry:lib",
      "target": ""
    }
  ]
}