{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "nft-card",
  "type": "registry:component",
  "title": "NFT Card",
  "description": "A versatile NFT display component that supports multiple blockchains with rich metadata and custom styling options",
  "dependencies": [
    "viem",
    "next/image",
    "viem"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/mini-app/blocks/nft-card/nft-card.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport Image from \"next/image\";\nimport { useState, useEffect } from \"react\";\n\ninterface NFTMetadata {\n  name?: string;\n  description?: string;\n  image?: string;\n  external_url?: string;\n  attributes?: Array<{\n    trait_type: string;\n    value: string | number;\n    display_type?: string;\n  }>;\n  [key: string]: unknown;\n}\nimport { createPublicClient, http, parseAbi, getAddress, Chain } from \"viem\";\nimport * as chains from \"viem/chains\";\n\n// Base64 placeholder image\nconst PLACEHOLDER_IMAGE =\n  \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgZmlsbD0iI2YxZjFmMSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjQiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiIGZpbGw9IiM5OTkiPk5GVCBJbWFnZTwvdGV4dD48L3N2Zz4=\";\n\n// ERC721 ABI for tokenURI and name functions\nconst erc721Abi = parseAbi([\n  \"function tokenURI(uint256 tokenId) view returns (string)\",\n  \"function name() view returns (string)\",\n  \"function symbol() view returns (string)\",\n  \"function ownerOf(uint256 tokenId) view returns (address)\",\n]);\n\n// Get all available chains from viem\nconst availableChains: Record<string, Chain> = {};\nObject.entries(chains).forEach(([name, chain]) => {\n  if (typeof chain === \"object\" && chain !== null && \"id\" in chain) {\n    availableChains[name.toLowerCase()] = chain as Chain;\n  }\n});\n\ntype NFTCardProps = {\n  contractAddress: string;\n  tokenId: string;\n  network?: string;\n  alt?: string;\n  className?: string;\n  width?: number;\n  height?: number;\n  rounded?: \"none\" | \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\n  shadow?: boolean;\n  objectFit?: \"contain\" | \"cover\" | \"fill\";\n  fallbackImageUrl?: string;\n  showTitle?: boolean;\n  showNetwork?: boolean;\n  titlePosition?: \"top\" | \"bottom\" | \"outside\";\n  networkPosition?:\n    | \"top-left\"\n    | \"top-right\"\n    | \"bottom-left\"\n    | \"bottom-right\"\n    | \"outside\";\n  customTitle?: string;\n  customNetworkName?: string;\n  loadingComponent?: React.ReactNode;\n  errorComponent?: React.ReactNode;\n  imageProps?: React.ComponentProps<typeof Image>;\n  titleClassName?: string;\n  networkClassName?: string;\n  showOwner?: boolean;\n  onLoad?: (metadata: NFTMetadata) => void;\n  onError?: (error: Error) => void;\n  layout?: \"compact\" | \"card\" | \"detailed\";\n  containerClassName?: string;\n};\n\nexport function NFTCard({\n  contractAddress,\n  tokenId,\n  network = \"ethereum\", // Default to Ethereum mainnet\n  alt = \"NFT Image\",\n  className = \"\",\n  width = 300,\n  height = 300,\n  rounded = \"md\",\n  shadow = true,\n  objectFit = \"cover\",\n  fallbackImageUrl = PLACEHOLDER_IMAGE,\n  showTitle = true,\n  showNetwork = true,\n  titlePosition = \"outside\",\n  networkPosition = \"top-right\",\n  customTitle,\n  customNetworkName,\n  loadingComponent,\n  errorComponent,\n  imageProps,\n  titleClassName = \"\",\n  networkClassName = \"\",\n  showOwner = false,\n  onLoad,\n  onError,\n  layout = \"card\",\n  containerClassName = \"\",\n}: NFTCardProps) {\n  const [imageUrl, setImageUrl] = useState<string>(fallbackImageUrl);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  const [title, setTitle] = useState<string | null>(customTitle || null);\n  const [networkName, setNetworkName] = useState<string>(\n    customNetworkName || \"\",\n  );\n  const [owner, setOwner] = useState<string | null>(null);\n\n  const roundedClasses = {\n    none: \"rounded-none\",\n    sm: \"rounded-sm\",\n    md: \"rounded-md\",\n    lg: \"rounded-lg\",\n    xl: \"rounded-xl\",\n    full: \"rounded-full\",\n  };\n\n  const networkPositionClasses = {\n    \"top-left\": \"top-0 left-0 rounded-br-md\",\n    \"top-right\": \"top-0 right-0 rounded-bl-md\",\n    \"bottom-left\": \"bottom-0 left-0 rounded-tr-md\",\n    \"bottom-right\": \"bottom-0 right-0 rounded-tl-md\",\n    outside: \"\",\n  };\n\n  useEffect(() => {\n    if (customTitle) {\n      setTitle(customTitle);\n    }\n\n    if (customNetworkName) {\n      setNetworkName(customNetworkName);\n    }\n  }, [customTitle, customNetworkName]);\n\n  useEffect(() => {\n    const fetchNFTData = async () => {\n      if (!contractAddress || !tokenId) return;\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        // Skip chain setup if we have customNetworkName\n        if (!customNetworkName) {\n          // Normalize network name\n          const normalizedNetwork = (network || \"ethereum\")\n            .toLowerCase()\n            .replace(/[\\s-]/g, \"\");\n\n          // Find the chain by name\n          let selectedChain: Chain | undefined;\n\n          // Try to find exact match first\n          if (availableChains[normalizedNetwork]) {\n            selectedChain = availableChains[normalizedNetwork];\n          } else {\n            // Try to find partial match\n            const matchingChainName = Object.keys(availableChains).find(\n              (chainName) =>\n                chainName.includes(normalizedNetwork) ||\n                normalizedNetwork.includes(chainName),\n            );\n\n            if (matchingChainName) {\n              selectedChain = availableChains[matchingChainName];\n            }\n          }\n\n          // Default to mainnet if no match found\n          if (!selectedChain) {\n            console.warn(\n              `Chain \"${network}\" not found, defaulting to Ethereum mainnet`,\n            );\n            selectedChain = chains.mainnet;\n            setNetworkName(\"Ethereum\");\n          } else {\n            setNetworkName(selectedChain.name);\n          }\n\n          // Create public client for the selected chain\n          const client = createPublicClient({\n            chain: selectedChain,\n            transport: http(),\n          });\n\n          console.log(\n            `Fetching NFT data from ${selectedChain.name} for contract ${contractAddress} token ${tokenId}`,\n          );\n\n          // Skip title setup if we have customTitle\n          if (!customTitle) {\n            try {\n              // Get contract name\n              const name = (await client.readContract({\n                address: getAddress(contractAddress),\n                abi: erc721Abi,\n                functionName: \"name\",\n              })) as string;\n\n              // Set title\n              setTitle(`${name} #${tokenId}`);\n            } catch (nameError) {\n              console.warn(\"Could not fetch NFT name:\", nameError);\n              setTitle(`NFT #${tokenId}`);\n            }\n          }\n\n          // Get owner if requested\n          if (showOwner) {\n            try {\n              const ownerAddress = (await client.readContract({\n                address: getAddress(contractAddress),\n                abi: erc721Abi,\n                functionName: \"ownerOf\",\n                args: [BigInt(tokenId)],\n              })) as string;\n\n              setOwner(ownerAddress);\n            } catch (ownerError) {\n              console.warn(\"Could not fetch NFT owner:\", ownerError);\n            }\n          }\n\n          // Get tokenURI\n          const tokenURI = (await client.readContract({\n            address: getAddress(contractAddress),\n            abi: erc721Abi,\n            functionName: \"tokenURI\",\n            args: [BigInt(tokenId)],\n          })) as string;\n\n          // Process tokenURI to get metadata\n          let metadataUrl = tokenURI;\n\n          // Handle IPFS URLs\n          if (metadataUrl.startsWith(\"ipfs://\")) {\n            metadataUrl = metadataUrl.replace(\n              \"ipfs://\",\n              \"https://ipfs.io/ipfs/\",\n            );\n          }\n\n          // Fetch metadata\n          const metadata = await fetch(metadataUrl).then((res) => res.json());\n          console.log(\"NFT metadata:\", metadata);\n\n          // Call onLoad callback if provided\n          if (onLoad) {\n            onLoad(metadata);\n          }\n\n          // Get image URL from metadata\n          let nftImageUrl = metadata.image;\n\n          // Handle IPFS URLs for image\n          if (nftImageUrl && nftImageUrl.startsWith(\"ipfs://\")) {\n            nftImageUrl = nftImageUrl.replace(\n              \"ipfs://\",\n              \"https://ipfs.io/ipfs/\",\n            );\n          }\n\n          if (nftImageUrl) {\n            setImageUrl(nftImageUrl);\n          } else {\n            // If no image URL found, use placeholder\n            setImageUrl(fallbackImageUrl);\n          }\n        }\n      } catch (err) {\n        console.error(\"Error fetching NFT:\", err);\n        const error = err instanceof Error ? err : new Error(String(err));\n        setError(`Failed to load NFT data: ${error.message}`);\n        setImageUrl(fallbackImageUrl);\n\n        // Call onError callback if provided\n        if (onError) {\n          onError(error);\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchNFTData();\n  }, [\n    contractAddress,\n    tokenId,\n    network,\n    fallbackImageUrl,\n    customTitle,\n    customNetworkName,\n    showOwner,\n    onLoad,\n    onError,\n  ]);\n\n  const defaultLoadingComponent = (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800\">\n      <div className=\"animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary\"></div>\n    </div>\n  );\n\n  const defaultErrorComponent = (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800\">\n      <p className=\"text-red-500 text-sm text-center px-2\">{error}</p>\n    </div>\n  );\n\n  // Render network badge inside the image\n  const renderNetworkBadge = () => {\n    if (!showNetwork || !networkName || networkPosition === \"outside\")\n      return null;\n\n    return (\n      <div\n        className={cn(\n          \"absolute bg-black/60 px-2 py-1 text-white text-xs\",\n          networkPositionClasses[networkPosition],\n          networkClassName,\n        )}\n      >\n        {networkName}\n      </div>\n    );\n  };\n\n  // Render title inside the image\n  const renderInnerTitle = () => {\n    if (!showTitle || !title || titlePosition === \"outside\") return null;\n\n    return (\n      <div\n        className={cn(\n          \"absolute left-0 right-0 bg-black/60 p-2 text-white text-sm truncate\",\n          titlePosition === \"top\" ? \"top-0\" : \"bottom-0\",\n          titleClassName,\n        )}\n      >\n        {title}\n        {showOwner && owner && (\n          <div className=\"text-xs opacity-70 truncate\">\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Render outside information (title, network, owner)\n  const renderOutsideInfo = () => {\n    if (\n      (!showTitle || !title) &&\n      (!showNetwork || !networkName || networkPosition !== \"outside\") &&\n      (!showOwner || !owner || titlePosition !== \"outside\")\n    ) {\n      return null;\n    }\n\n    return (\n      <div className=\"mt-2\">\n        {showTitle && title && titlePosition === \"outside\" && (\n          <div className={cn(\"text-sm font-medium truncate\", titleClassName)}>\n            {title}\n          </div>\n        )}\n\n        {showNetwork && networkName && networkPosition === \"outside\" && (\n          <div\n            className={cn(\n              \"text-xs text-gray-500 dark:text-gray-400\",\n              networkClassName,\n            )}\n          >\n            Network: {networkName}\n          </div>\n        )}\n\n        {showOwner && owner && titlePosition === \"outside\" && (\n          <div className=\"text-xs text-gray-500 dark:text-gray-400 truncate\">\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Apply different layouts\n  const getContainerClasses = () => {\n    switch (layout) {\n      case \"compact\":\n        return \"inline-block\";\n      case \"detailed\":\n        return \"flex flex-col overflow-hidden\";\n      case \"card\":\n      default:\n        return \"\";\n    }\n  };\n\n  // Create CSS class for width and height\n  // Dimension classes will be applied via className\n\n  return (\n    <div className={cn(getContainerClasses(), containerClassName)}>\n      <div\n        className={cn(\n          \"relative overflow-hidden\",\n          roundedClasses[rounded],\n          shadow && \"shadow-md\",\n          className,\n        )}\n        style={{ width: `${width}px`, height: `${height}px` }} // Using style prop as a last resort for dynamic dimensions\n      >\n        {isLoading && (loadingComponent || defaultLoadingComponent)}\n\n        {error && (errorComponent || defaultErrorComponent)}\n\n        <Image\n          src={imageUrl}\n          alt={alt}\n          fill={true}\n          className={cn(\"object-\" + objectFit, isLoading && \"opacity-0\")}\n          unoptimized={true}\n          onError={() => setImageUrl(PLACEHOLDER_IMAGE)}\n          {...imageProps}\n        />\n\n        {renderInnerTitle()}\n        {renderNetworkBadge()}\n      </div>\n\n      {renderOutsideInfo()}\n    </div>\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}