{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "nft-card",
  "type": "registry:component",
  "title": "NFT Card",
  "description": "A versatile NFT display component that supports multiple blockchains with rich metadata and custom styling options",
  "dependencies": [
    "viem",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "https://hellno-mini-app-ui.vercel.app/r/utils.json",
    "https://hellno-mini-app-ui.vercel.app/r/chains.json",
    "https://hellno-mini-app-ui.vercel.app/r/nft-standards.json",
    "https://hellno-mini-app-ui.vercel.app/r/manifold-utils.json"
  ],
  "files": [
    {
      "path": "registry/mini-app/blocks/nft-card/nft-card.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/registry/mini-app/lib/utils\";\nimport Image from \"next/image\";\nimport { useState, useEffect, useRef } from \"react\";\n\ninterface NFTMetadata {\n  name?: string;\n  description?: string;\n  image?: string;\n  image_url?: string;\n  external_url?: string;\n  attributes?: Array<{\n    trait_type: string;\n    value: string | number;\n    display_type?: string;\n  }>;\n  image_details?: {\n    bytes?: number;\n    format?: string;\n    sha256?: string;\n    width?: number;\n    height?: number;\n  };\n  [key: string]: unknown;\n}\nimport { getAddress, type Address } from \"viem\";\nimport { \n  findChainByName, \n  getPublicClient \n} from \"@/registry/mini-app/lib/chains\";\nimport { \n  ERC721_ABI, \n  ipfsToHttp \n} from \"@/registry/mini-app/lib/nft-standards\";\nimport { \n  getTokenURIWithManifoldSupport \n} from \"@/registry/mini-app/lib/manifold-utils\";\n\n// Base64 placeholder image\nconst PLACEHOLDER_IMAGE =\n  \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgZmlsbD0iI2YxZjFmMSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjQiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiIGZpbGw9IiM5OTkiPk5GVCBJbWFnZTwvdGV4dD48L3N2Zz4=\";\n\n\ntype NFTCardProps = {\n  contractAddress: string;\n  tokenId: string;\n  network?: string;\n  alt?: string;\n  className?: string;\n  width?: number | string;\n  height?: number | string;\n  rounded?: \"none\" | \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\n  shadow?: boolean;\n  objectFit?: \"contain\" | \"cover\" | \"fill\";\n  fallbackImageUrl?: string;\n  showTitle?: boolean;\n  showNetwork?: boolean;\n  titlePosition?: \"top\" | \"bottom\" | \"outside\";\n  networkPosition?:\n    | \"top-left\"\n    | \"top-right\"\n    | \"bottom-left\"\n    | \"bottom-right\"\n    | \"outside\";\n  customTitle?: string;\n  customNetworkName?: string;\n  loadingComponent?: React.ReactNode;\n  errorComponent?: React.ReactNode;\n  imageProps?: React.ComponentProps<typeof Image>;\n  titleClassName?: string;\n  networkClassName?: string;\n  showOwner?: boolean;\n  onLoad?: (metadata: NFTMetadata) => void;\n  onError?: (error: Error) => void;\n  layout?: \"compact\" | \"card\" | \"detailed\";\n  containerClassName?: string;\n};\n\nexport function NFTCard({\n  contractAddress,\n  tokenId,\n  network = \"ethereum\", // Default to Ethereum mainnet\n  alt = \"NFT Image\",\n  className = \"\",\n  width = 300,\n  height = 300,\n  rounded = \"md\",\n  shadow = true,\n  objectFit = \"cover\",\n  fallbackImageUrl = PLACEHOLDER_IMAGE,\n  showTitle = true,\n  showNetwork = true,\n  titlePosition = \"outside\",\n  networkPosition = \"top-right\",\n  customTitle,\n  customNetworkName,\n  loadingComponent,\n  errorComponent,\n  imageProps,\n  titleClassName = \"\",\n  networkClassName = \"\",\n  showOwner = false,\n  onLoad,\n  onError,\n  layout = \"card\",\n  containerClassName = \"\",\n}: NFTCardProps) {\n  const [imageUrl, setImageUrl] = useState<string>(fallbackImageUrl);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  const [title, setTitle] = useState<string | null>(customTitle || null);\n  const [networkName, setNetworkName] = useState<string>(\n    customNetworkName || \"\",\n  );\n  const [owner, setOwner] = useState<string | null>(null);\n  const [metadata, setMetadata] = useState<NFTMetadata | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const roundedClasses = {\n    none: \"rounded-none\",\n    sm: \"rounded-sm\",\n    md: \"rounded-md\",\n    lg: \"rounded-lg\",\n    xl: \"rounded-xl\",\n    full: \"rounded-full\",\n  };\n\n  const networkPositionClasses = {\n    \"top-left\": \"top-0 left-0 rounded-br-md\",\n    \"top-right\": \"top-0 right-0 rounded-bl-md\",\n    \"bottom-left\": \"bottom-0 left-0 rounded-tr-md\",\n    \"bottom-right\": \"bottom-0 right-0 rounded-tl-md\",\n    outside: \"\",\n  };\n\n  useEffect(() => {\n    if (customTitle) {\n      setTitle(customTitle);\n    }\n\n    if (customNetworkName) {\n      setNetworkName(customNetworkName);\n    }\n  }, [customTitle, customNetworkName]);\n\n  useEffect(() => {\n    const fetchNFTData = async () => {\n      if (!contractAddress || !tokenId) return;\n      \n      // Cancel any previous request\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      \n      // Create new AbortController for this request\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        // Skip chain setup if we have customNetworkName\n        if (!customNetworkName) {\n          // Find the chain by name using shared utility\n          const selectedChain = findChainByName(network || \"ethereum\");\n          \n          if (!selectedChain) {\n            console.warn(\n              `Chain \"${network}\" not found, defaulting to Ethereum mainnet`,\n            );\n            setNetworkName(\"Ethereum\");\n          } else {\n            setNetworkName(selectedChain.name);\n          }\n\n          // Create public client using shared utility\n          const client = getPublicClient(selectedChain?.id || 1);\n\n          console.log(\n            `Fetching NFT data from ${selectedChain?.name || 'Ethereum'} for contract ${contractAddress} token ${tokenId}`,\n          );\n\n          // Skip title setup if we have customTitle\n          if (!customTitle) {\n            try {\n              // Get contract name\n              const name = (await client.readContract({\n                address: getAddress(contractAddress),\n                abi: ERC721_ABI.name,\n                functionName: \"name\",\n              })) as string;\n\n              // Set title\n              setTitle(`${name} #${tokenId}`);\n            } catch (nameError) {\n              console.warn(\"Could not fetch NFT name:\", nameError);\n              setTitle(`NFT #${tokenId}`);\n            }\n          }\n\n          // Get owner if requested\n          if (showOwner) {\n            try {\n              const ownerAddress = (await client.readContract({\n                address: getAddress(contractAddress),\n                abi: ERC721_ABI.ownerOf,\n                functionName: \"ownerOf\",\n                args: [BigInt(tokenId)],\n              })) as string;\n\n              setOwner(ownerAddress);\n            } catch (ownerError) {\n              console.warn(\"Could not fetch NFT owner:\", ownerError);\n            }\n          }\n\n          // Get tokenURI with automatic Manifold support\n          let metadataUrl = await getTokenURIWithManifoldSupport(\n            client,\n            getAddress(contractAddress) as Address,\n            tokenId\n          );\n\n          // Handle IPFS URLs using shared utility\n          metadataUrl = ipfsToHttp(metadataUrl);\n\n          // Fetch metadata with abort signal\n          const response = await fetch(metadataUrl, {\n            signal: abortController.signal\n          });\n          \n          if (!response.ok) {\n            throw new Error(`Failed to fetch metadata: ${response.status}`);\n          }\n          \n          const fetchedMetadata = await response.json();\n          console.log(\"NFT metadata:\", fetchedMetadata);\n          \n          // Store metadata in state\n          setMetadata(fetchedMetadata);\n\n          // Call onLoad callback if provided\n          if (onLoad) {\n            onLoad(fetchedMetadata);\n          }\n\n          // Get image URL from metadata\n          let nftImageUrl = fetchedMetadata.image || fetchedMetadata.image_url;\n\n          // Handle IPFS URLs for image using shared utility\n          if (nftImageUrl) {\n            nftImageUrl = ipfsToHttp(nftImageUrl);\n          }\n\n          if (nftImageUrl) {\n            setImageUrl(nftImageUrl);\n          } else {\n            // If no image URL found, use placeholder\n            setImageUrl(fallbackImageUrl);\n          }\n        }\n      } catch (err) {\n        // Don't update state if request was aborted\n        if (err instanceof Error && err.name === 'AbortError') {\n          console.log('NFT data fetch was cancelled');\n          return;\n        }\n        \n        console.error(\"Error fetching NFT:\", err);\n        const error = err instanceof Error ? err : new Error(String(err));\n        setError(`Failed to load NFT data: ${error.message}`);\n        setImageUrl(fallbackImageUrl);\n\n        // Call onError callback if provided\n        if (onError) {\n          onError(error);\n        }\n      } finally {\n        // Only update loading state if this request wasn't aborted\n        if (!abortController.signal.aborted) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    fetchNFTData();\n    \n    // Cleanup function to abort request if component unmounts or deps change\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [\n    contractAddress,\n    tokenId,\n    network,\n    fallbackImageUrl,\n    customTitle,\n    customNetworkName,\n    showOwner,\n    onLoad,\n    onError,\n  ]);\n\n  const defaultLoadingComponent = (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-300 dark:bg-gray-700\">\n      <div className=\"w-full h-full bg-gray-200 dark:bg-gray-800 animate-pulse\"></div>\n    </div>\n  );\n\n  const defaultErrorComponent = (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800\">\n      <p className=\"text-red-500 text-sm text-center px-2\">{error}</p>\n    </div>\n  );\n\n  // Render network badge inside the image\n  const renderNetworkBadge = () => {\n    if (!showNetwork || !networkName || networkPosition === \"outside\")\n      return null;\n\n    return (\n      <div\n        className={cn(\n          \"absolute bg-black/60 px-2 py-1 text-white text-xs\",\n          networkPositionClasses[networkPosition],\n          networkClassName,\n        )}\n      >\n        {networkName}\n      </div>\n    );\n  };\n\n  // Render title inside the image\n  const renderInnerTitle = () => {\n    if (!showTitle || !title || titlePosition === \"outside\") return null;\n\n    return (\n      <div\n        className={cn(\n          \"absolute left-0 right-0 bg-black/60 p-2 text-white text-sm truncate\",\n          titlePosition === \"top\" ? \"top-0\" : \"bottom-0\",\n          titleClassName,\n        )}\n      >\n        {title}\n        {showOwner && owner && (\n          <div className=\"text-xs opacity-70 truncate\">\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Render outside information (title, network, owner)\n  const renderOutsideInfo = () => {\n    if (\n      (!showTitle || !title) &&\n      (!showNetwork || !networkName || networkPosition !== \"outside\") &&\n      (!showOwner || !owner || titlePosition !== \"outside\")\n    ) {\n      return null;\n    }\n\n    return (\n      <div className=\"mt-2\">\n        {showTitle && title && titlePosition === \"outside\" && (\n          <div className={cn(\"text-sm font-medium truncate\", titleClassName)}>\n            {title}\n          </div>\n        )}\n\n        {showNetwork && networkName && networkPosition === \"outside\" && (\n          <div\n            className={cn(\n              \"text-xs text-gray-500 dark:text-gray-400\",\n              networkClassName,\n            )}\n          >\n            Network: {networkName}\n          </div>\n        )}\n\n        {showOwner && owner && titlePosition === \"outside\" && (\n          <div className=\"text-xs text-gray-500 dark:text-gray-400 truncate\">\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Apply different layouts\n  const getContainerClasses = () => {\n    switch (layout) {\n      case \"compact\":\n        return \"inline-block\";\n      case \"detailed\":\n        return \"flex flex-col overflow-hidden\";\n      case \"card\":\n      default:\n        return \"\";\n    }\n  };\n\n  // Calculate display dimensions that preserve aspect ratio\n  const getDisplayDimensions = () => {\n    // Handle percentage values\n    const isPercentageWidth = typeof width === 'string' && width.includes('%');\n    const isPercentageHeight = typeof height === 'string' && height.includes('%');\n    \n    if (isPercentageWidth || isPercentageHeight) {\n      return { \n        width: width || '100%', \n        height: height || '100%', \n        useContain: false,\n        isPercentage: true\n      };\n    }\n    \n    const maxWidth = typeof width === 'number' ? width : 300;\n    const maxHeight = typeof height === 'number' ? height : 300;\n    \n    // Check if we have image_details with dimensions\n    if (metadata?.image_details?.width && metadata?.image_details?.height) {\n      const originalAspectRatio = metadata.image_details.width / metadata.image_details.height;\n      \n      // Scale to fit within bounds while preserving aspect ratio\n      const widthBasedHeight = maxWidth / originalAspectRatio;\n      const heightBasedWidth = maxHeight * originalAspectRatio;\n      \n      if (widthBasedHeight <= maxHeight) {\n        // Width is the limiting factor\n        return { \n          width: maxWidth, \n          height: Math.round(widthBasedHeight),\n          useContain: true, // Use contain to show full image\n          isPercentage: false\n        };\n      } else {\n        // Height is the limiting factor\n        return { \n          width: Math.round(heightBasedWidth), \n          height: maxHeight,\n          useContain: true,\n          isPercentage: false\n        };\n      }\n    }\n    \n    // No image_details, use provided dimensions\n    return { width: maxWidth, height: maxHeight, useContain: false, isPercentage: false };\n  };\n\n  const displayDimensions = getDisplayDimensions();\n\n  return (\n    <div className={cn(getContainerClasses(), containerClassName)}>\n      <div\n        className={cn(\n          \"relative overflow-hidden\",\n          roundedClasses[rounded],\n          shadow && \"shadow-md\",\n          className,\n        )}\n        style={{ \n          width: displayDimensions.isPercentage \n            ? displayDimensions.width \n            : `${displayDimensions.width}px`, \n          height: displayDimensions.isPercentage \n            ? displayDimensions.height \n            : `${displayDimensions.height}px` \n        }}\n      >\n        {isLoading && (loadingComponent || defaultLoadingComponent)}\n\n        {error && (errorComponent || defaultErrorComponent)}\n\n        <Image\n          src={imageUrl}\n          alt={alt}\n          fill={true}\n          className={cn(\n            displayDimensions.useContain || displayDimensions.isPercentage ? \"object-contain\" : `object-${objectFit}`,\n            isLoading && \"opacity-0\"\n          )}\n          unoptimized={true}\n          onError={() => setImageUrl(PLACEHOLDER_IMAGE)}\n          {...imageProps}\n        />\n\n        {renderInnerTitle()}\n        {renderNetworkBadge()}\n      </div>\n\n      {renderOutsideInfo()}\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/mini-app/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/chains.ts",
      "content": "import { http, type Chain, type PublicClient, createPublicClient } from \"viem\";\nimport * as chains from \"viem/chains\";\n\n/**\n * Supported chains configuration with Alchemy RPC support\n */\nexport const SUPPORTED_CHAINS = [\n  { id: 1, chain: chains.mainnet, alchemyPrefix: \"eth-mainnet\" },\n  { id: 8453, chain: chains.base, alchemyPrefix: \"base-mainnet\" },\n  { id: 42161, chain: chains.arbitrum, alchemyPrefix: \"arb-mainnet\" },\n  { id: 421614, chain: chains.arbitrumSepolia, alchemyPrefix: \"arb-sepolia\" },\n  { id: 84532, chain: chains.baseSepolia, alchemyPrefix: \"base-sepolia\" },\n  { id: 666666666, chain: chains.degen, alchemyPrefix: \"degen-mainnet\" },\n  { id: 100, chain: chains.gnosis, alchemyPrefix: \"gnosis-mainnet\" },\n  { id: 10, chain: chains.optimism, alchemyPrefix: \"opt-mainnet\" },\n  { id: 11155420, chain: chains.optimismSepolia, alchemyPrefix: \"opt-sepolia\" },\n  { id: 137, chain: chains.polygon, alchemyPrefix: \"polygon-mainnet\" },\n  { id: 11155111, chain: chains.sepolia, alchemyPrefix: \"eth-sepolia\" },\n  { id: 7777777, chain: chains.zora, alchemyPrefix: \"zora-mainnet\" },\n  { id: 130, chain: chains.ham, alchemyPrefix: \"unichain-mainnet\" }, // Unichain\n  {\n    id: 10143,\n    chain: {\n      id: 10143,\n      name: \"Monad Testnet\",\n      network: \"monad-testnet\",\n      nativeCurrency: { name: \"Monad\", symbol: \"MON\", decimals: 18 },\n      rpcUrls: {\n        default: { http: [\"https://testnet.monad.xyz\"] },\n        public: { http: [\"https://testnet.monad.xyz\"] },\n      },\n    } as const,\n    alchemyPrefix: null,\n  },\n  { id: 42220, chain: chains.celo, alchemyPrefix: null },\n] as const;\n\n/**\n * Get viem Chain object by ID\n */\nexport function getChainById(chainId: number): Chain {\n  const config = SUPPORTED_CHAINS.find((c) => c.id === chainId);\n  return config?.chain || chains.mainnet;\n}\n\n/**\n * Get HTTP transport with optional Alchemy RPC URL\n * Falls back to public RPC if no Alchemy key is available\n */\nexport function getTransport(chainId: number) {\n  const alchemyKey = process.env.NEXT_PUBLIC_ALCHEMY_KEY;\n  const config = SUPPORTED_CHAINS.find((c) => c.id === chainId);\n\n  if (config?.alchemyPrefix && alchemyKey) {\n    return http(\n      `https://${config.alchemyPrefix}.g.alchemy.com/v2/${alchemyKey}`,\n    );\n  }\n\n  // Fallback to default public RPC\n  return http();\n}\n\n/**\n * Create a public client for a specific chain with optimal transport\n */\nexport function getPublicClient(chainId: number): PublicClient {\n  return createPublicClient({\n    chain: getChainById(chainId),\n    transport: getTransport(chainId),\n  }) as PublicClient;\n}\n\n/**\n * Find chain by network name (case-insensitive)\n */\nexport function findChainByName(networkName: string): Chain | undefined {\n  const normalizedName = networkName.toLowerCase().trim();\n  \n  // Direct name mappings\n  const nameToId: Record<string, number> = {\n    ethereum: 1,\n    mainnet: 1,\n    base: 8453,\n    arbitrum: 42161,\n    \"arbitrum one\": 42161,\n    \"arbitrum sepolia\": 421614,\n    \"base sepolia\": 84532,\n    degen: 666666666,\n    gnosis: 100,\n    optimism: 10,\n    \"optimism sepolia\": 11155420,\n    polygon: 137,\n    sepolia: 11155111,\n    \"ethereum sepolia\": 11155111,\n    zora: 7777777,\n    unichain: 130,\n    ham: 130,\n    \"monad testnet\": 10143,\n    monad: 10143,\n    celo: 42220,\n  };\n  \n  const chainId = nameToId[normalizedName];\n  return chainId ? getChainById(chainId) : undefined;\n}\n\n/**\n * Get Alchemy RPC endpoint URL for a specific chain\n */\nexport function getAlchemyEndpoint(chainId: number, apiKey: string): string | undefined {\n  const config = SUPPORTED_CHAINS.find((c) => c.id === chainId);\n  \n  if (config?.alchemyPrefix && apiKey) {\n    return `https://${config.alchemyPrefix}.g.alchemy.com/v2/${apiKey}`;\n  }\n  \n  return undefined;\n}\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/nft-standards.ts",
      "content": "import { parseAbi, type Address } from \"viem\";\n\n/**\n * Common NFT contract ABIs and standards\n */\n\n// Standard ERC721 functions\nexport const ERC721_ABI = {\n  full: parseAbi([\n    \"function tokenURI(uint256 tokenId) view returns (string)\",\n    \"function name() view returns (string)\",\n    \"function symbol() view returns (string)\",\n    \"function ownerOf(uint256 tokenId) view returns (address)\",\n    \"function balanceOf(address owner) view returns (uint256)\",\n    \"function totalSupply() view returns (uint256)\",\n  ]),\n  \n  // Individual functions for specific use cases\n  tokenURI: parseAbi([\"function tokenURI(uint256 tokenId) view returns (string)\"]),\n  name: parseAbi([\"function name() view returns (string)\"]),\n  symbol: parseAbi([\"function symbol() view returns (string)\"]),\n  ownerOf: parseAbi([\"function ownerOf(uint256 tokenId) view returns (address)\"]),\n};\n\n// Common price discovery functions across NFT contracts\nexport const PRICE_DISCOVERY_ABI = parseAbi([\n  \"function mintPrice() view returns (uint256)\",\n  \"function price() view returns (uint256)\",\n  \"function MINT_PRICE() view returns (uint256)\",\n  \"function getMintPrice() view returns (uint256)\",\n  \"function publicMintPrice() view returns (uint256)\",\n]);\n\n// Common mint functions\nexport const MINT_ABI = parseAbi([\n  \"function mint(uint256 amount) payable\",\n  \"function mint(address to, uint256 amount) payable\",\n  \"function publicMint(uint256 amount) payable\",\n  \"function mintTo(address to, uint256 amount) payable\",\n]);\n\n// ERC20 ABI for token interactions\nexport const ERC20_ABI = parseAbi([\n  \"function decimals() view returns (uint8)\",\n  \"function symbol() view returns (string)\",\n  \"function name() view returns (string)\",\n  \"function totalSupply() view returns (uint256)\",\n  \"function balanceOf(address owner) view returns (uint256)\",\n  \"function allowance(address owner, address spender) view returns (uint256)\",\n  \"function approve(address spender, uint256 value) returns (bool)\",\n  \"function transfer(address to, uint256 value) returns (bool)\",\n  \"function transferFrom(address from, address to, uint256 value) returns (bool)\",\n]);\n\n// Manifold contract detection ABI (kept separate as it's used on the main contract)\nexport const MANIFOLD_DETECTION_ABI = parseAbi([\n  \"function getExtensions() view returns (address[])\",\n]);\n\n// Manifold extension contract full ABI\nexport const MANIFOLD_EXTENSION_ABI = [\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"tokenURI\",\n    outputs: [{ name: \"uri\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" }\n    ],\n    name: \"getClaim\",\n    outputs: [\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"tokenId\", type: \"uint256\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"getClaimForToken\",\n    outputs: [\n      { name: \"instanceId\", type: \"uint256\" },\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"tokenId\", type: \"uint256\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" },\n      { name: \"mintIndex\", type: \"uint32\" },\n      { name: \"merkleProof\", type: \"bytes32[]\" },\n      { name: \"mintFor\", type: \"address\" }\n    ],\n    name: \"mint\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE_MERKLE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n] as const;\n\n// ERC165 interface detection\nexport const ERC165_ABI = parseAbi([\n  \"function supportsInterface(bytes4 interfaceId) view returns (bool)\",\n]);\n\n// Known contract addresses\nexport const KNOWN_CONTRACTS = {\n  // Manifold extension contracts\n  manifoldExtension: \"0x26BBEA7803DcAc346D5F5f135b57Cf2c752A02bE\" as Address,\n  \n  // Add other known contracts here as needed\n} as const;\n\n// Interface IDs for contract detection\nexport const INTERFACE_IDS = {\n  ERC165: \"0x01ffc9a7\",\n  ERC721: \"0x80ac58cd\",\n  ERC1155: \"0xd9b67a26\",\n  ERC721Metadata: \"0x5b5e139f\",\n} as const;\n\n// IPFS Gateway configuration\nexport const IPFS_GATEWAYS = {\n  default: \"https://ipfs.io/ipfs/\",\n  cloudflare: \"https://cloudflare-ipfs.com/ipfs/\",\n  pinata: \"https://gateway.pinata.cloud/ipfs/\",\n} as const;\n\n/**\n * Convert IPFS URL to HTTP gateway URL\n */\nexport function ipfsToHttp(url: string, gateway?: keyof typeof IPFS_GATEWAYS): string {\n  const selectedGateway = gateway || \"default\";\n  if (!url || !url.startsWith(\"ipfs://\")) {\n    return url;\n  }\n  \n  return url.replace(\"ipfs://\", IPFS_GATEWAYS[selectedGateway]);\n}\n\n/**\n * Check if a contract is likely an NFT contract by checking interface support\n */\nexport async function isNFTContract(\n  client: any,\n  contractAddress: Address\n): Promise<{ isNFT: boolean; type?: 'ERC721' | 'ERC1155' }> {\n  try {\n    // Try ERC165 supportsInterface\n    const [supportsERC721, supportsERC1155] = await Promise.all([\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC721],\n      }).catch(() => false),\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC1155],\n      }).catch(() => false),\n    ]);\n    \n    if (supportsERC721) return { isNFT: true, type: 'ERC721' };\n    if (supportsERC1155) return { isNFT: true, type: 'ERC1155' };\n    \n    // Fallback: try to call name() function\n    const name = await client.readContract({\n      address: contractAddress,\n      abi: ERC721_ABI.name,\n      functionName: 'name',\n    }).catch(() => null);\n    \n    return { isNFT: !!name };\n  } catch {\n    return { isNFT: false };\n  }\n}",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/manifold-utils.ts",
      "content": "import { type Address, type PublicClient, getAddress } from \"viem\";\nimport { MANIFOLD_DETECTION_ABI, MANIFOLD_EXTENSION_ABI, KNOWN_CONTRACTS, ERC721_ABI } from \"@/registry/mini-app/lib/nft-standards\";\n\n/**\n * Manifold contract utilities\n */\n\nexport interface ManifoldDetectionResult {\n  isManifold: boolean;\n  extensionAddress?: Address;\n  extensions?: Address[];\n}\n\nexport interface ManifoldClaim {\n  total: number;\n  totalMax: number;\n  walletMax: number;\n  startDate: bigint;\n  endDate: bigint;\n  storageProtocol: number;\n  merkleRoot: `0x${string}`;\n  location: string;\n  tokenId: bigint;\n  cost: bigint;\n  paymentReceiver: Address;\n  erc20: Address;\n  signingAddress: Address;\n}\n\n/**\n * Detect if a contract is a Manifold contract with extensions\n */\nexport async function detectManifoldContract(\n  client: PublicClient,\n  contractAddress: Address\n): Promise<ManifoldDetectionResult> {\n  try {\n    const extensions = await client.readContract({\n      address: getAddress(contractAddress),\n      abi: MANIFOLD_DETECTION_ABI,\n      functionName: \"getExtensions\",\n    }) as Address[];\n    \n    if (!extensions || extensions.length === 0) {\n      return { isManifold: false };\n    }\n    \n    // Check if it has the known Manifold extension\n    const knownExtension = extensions.find(\n      ext => ext.toLowerCase() === KNOWN_CONTRACTS.manifoldExtension.toLowerCase()\n    );\n    \n    return {\n      isManifold: true,\n      extensionAddress: knownExtension || extensions[0],\n      extensions,\n    };\n  } catch {\n    return { isManifold: false };\n  }\n}\n\n/**\n * Get token URI for a Manifold NFT\n */\nexport async function getManifoldTokenURI(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string,\n  extensionAddress?: Address\n): Promise<string> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  return await client.readContract({\n    address: getAddress(extension),\n    abi: MANIFOLD_EXTENSION_ABI,\n    functionName: \"tokenURI\",\n    args: [getAddress(contractAddress), BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get token URI with automatic Manifold detection\n */\nexport async function getTokenURIWithManifoldSupport(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string\n): Promise<string> {\n  // Try Manifold first\n  const manifoldInfo = await detectManifoldContract(client, contractAddress);\n  \n  if (manifoldInfo.isManifold && manifoldInfo.extensionAddress) {\n    try {\n      return await getManifoldTokenURI(\n        client,\n        contractAddress,\n        tokenId,\n        manifoldInfo.extensionAddress\n      );\n    } catch (error) {\n      console.warn(\"Failed to get Manifold tokenURI, falling back to standard\", error);\n    }\n  }\n  \n  // Fallback to standard ERC721 tokenURI\n  return await client.readContract({\n    address: getAddress(contractAddress),\n    abi: ERC721_ABI.tokenURI,\n    functionName: \"tokenURI\",\n    args: [BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get Manifold claim information\n */\nexport async function getManifoldClaim(\n  client: PublicClient,\n  contractAddress: Address,\n  instanceId: string,\n  extensionAddress?: Address\n): Promise<ManifoldClaim | null> {\n  try {\n    const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n    \n    const claim = await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"getClaim\",\n      args: [getAddress(contractAddress), BigInt(instanceId)],\n    });\n    \n    return claim as unknown as ManifoldClaim;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get Manifold mint fee\n */\nexport async function getManifoldMintFee(\n  client: PublicClient,\n  extensionAddress?: Address\n): Promise<bigint> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  try {\n    return await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"MINT_FEE\",\n    }) as bigint;\n  } catch {\n    // Try MINT_FEE_MERKLE as fallback\n    try {\n      return await client.readContract({\n        address: getAddress(extension),\n        abi: MANIFOLD_EXTENSION_ABI,\n        functionName: \"MINT_FEE_MERKLE\",\n      }) as bigint;\n    } catch {\n      return BigInt(0);\n    }\n  }\n}\n\n/**\n * Check if an address is the zero address\n */\nexport function isZeroAddress(address: string): boolean {\n  return address === \"0x0000000000000000000000000000000000000000\";\n}\n\n/**\n * Format instance ID and token ID for display\n */\nexport function formatManifoldTokenId(instanceId: string, tokenId: string): string {\n  return `${instanceId}-${tokenId}`;\n}",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "meta": {
    "use_cases": [
      "NFT Showcase",
      "Digital Collectibles Display"
    ],
    "keywords": [
      "nft",
      "collectible",
      "mint"
    ]
  }
}