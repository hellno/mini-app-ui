{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "nft-card",
  "type": "registry:component",
  "title": "NFT Card",
  "description": "A versatile NFT display component that supports multiple blockchains with rich metadata and custom styling options",
  "dependencies": [
    "viem",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "https://hellno-mini-app-ui.vercel.app/r/utils.json",
    "https://hellno-mini-app-ui.vercel.app/r/chains.json",
    "https://hellno-mini-app-ui.vercel.app/r/nft-standards.json",
    "https://hellno-mini-app-ui.vercel.app/r/nft-metadata-utils.json"
  ],
  "files": [
    {
      "path": "registry/mini-app/blocks/nft-card/nft-card.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/registry/mini-app/lib/utils\";\nimport Image from \"next/image\";\nimport { useState, useEffect, useRef } from \"react\";\n\ninterface NFTMetadata {\n  name?: string;\n  description?: string;\n  image?: string;\n  image_url?: string;\n  animation_url?: string;\n  external_url?: string;\n  attributes?: Array<{\n    trait_type: string;\n    value: string | number;\n    display_type?: string;\n  }>;\n  image_details?: {\n    bytes?: number;\n    format?: string;\n    sha256?: string;\n    width?: number;\n    height?: number;\n  };\n  [key: string]: unknown;\n}\nimport { getAddress, type Address } from \"viem\";\nimport { \n  findChainByName, \n  getPublicClient \n} from \"@/registry/mini-app/lib/chains\";\nimport { \n  ERC721_ABI, \n  ipfsToHttp \n} from \"@/registry/mini-app/lib/nft-standards\";\nimport { \n  getTokenMetadataURL \n} from \"@/registry/mini-app/lib/nft-metadata-utils\";\n\n// Base64 placeholder image\nconst PLACEHOLDER_IMAGE =\n  \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgZmlsbD0iI2YxZjFmMSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjQiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiIGZpbGw9IiM5OTkiPk5GVCBJbWFnZTwvdGV4dD48L3N2Zz4=\";\n\n\ninterface NFTCardProps {\n  // Essential props\n  contractAddress: string;\n  tokenId: string;\n  network?: string;\n  \n  // Display size - single prop that handles both dimensions\n  size?: number | string;\n  \n  // All display options grouped (all optional with smart defaults)\n  displayOptions?: {\n    showTitle?: boolean;\n    showNetwork?: boolean; \n    rounded?: \"none\" | \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\n    shadow?: boolean;\n  };\n  \n  // Standard React props\n  className?: string;\n  onLoad?: (metadata: NFTMetadata) => void;\n  onError?: (error: Error) => void;\n}\n\nexport function NFTCard({\n  contractAddress,\n  tokenId,\n  network = \"ethereum\",\n  size = 300,\n  displayOptions = {},\n  className = \"\",\n  onLoad,\n  onError,\n}: NFTCardProps) {\n  // Extract display options with defaults\n  const {\n    showTitle = true,\n    showNetwork = true,\n    rounded = \"md\",\n    shadow = true,\n  } = displayOptions;\n  const [imageUrl, setImageUrl] = useState<string>(PLACEHOLDER_IMAGE);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  const [title, setTitle] = useState<string | null>(null);\n  const [networkName, setNetworkName] = useState<string>(\"\");\n  const [metadata, setMetadata] = useState<NFTMetadata | null>(null);\n  const [videoUrl, setVideoUrl] = useState<string | null>(null);\n  const [videoDimensions, setVideoDimensions] = useState<{ width: number; height: number } | null>(null);\n  const [imageDimensions, setImageDimensions] = useState<{ width: number; height: number } | null>(null);\n  const [isVideo, setIsVideo] = useState<boolean>(false);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const roundedClasses = {\n    none: \"rounded-none\",\n    sm: \"rounded-sm\",\n    md: \"rounded-md\",\n    lg: \"rounded-lg\",\n    xl: \"rounded-xl\",\n    full: \"rounded-full\",\n  };\n\n  const networkPositionClasses = {\n    \"top-left\": \"top-0 left-0 rounded-br-md\",\n    \"top-right\": \"top-0 right-0 rounded-bl-md\",\n    \"bottom-left\": \"bottom-0 left-0 rounded-tr-md\",\n    \"bottom-right\": \"bottom-0 right-0 rounded-tl-md\",\n    outside: \"\",\n  };\n\n\n  useEffect(() => {\n    const fetchNFTData = async () => {\n      if (!contractAddress || !tokenId) return;\n      \n      // Cancel any previous request\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      \n      // Create new AbortController for this request\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        // Find the chain by name using shared utility\n        const selectedChain = findChainByName(network || \"ethereum\");\n        \n        if (!selectedChain) {\n          console.warn(\n            `Chain \"${network}\" not found, defaulting to Ethereum mainnet`,\n          );\n          setNetworkName(\"Ethereum\");\n        } else {\n          setNetworkName(selectedChain.name);\n        }\n\n        // Create public client using shared utility\n        const client = getPublicClient(selectedChain?.id || 1);\n\n        console.log(\n          `Fetching NFT data from ${selectedChain?.name || 'Ethereum'} for contract ${contractAddress} token ${tokenId}`,\n        );\n\n        // Get contract name for title\n        try {\n          // Get contract name\n          const name = (await client.readContract({\n            address: getAddress(contractAddress),\n            abi: ERC721_ABI.name,\n            functionName: \"name\",\n          })) as string;\n\n          // Set title\n          setTitle(`${name} #${tokenId}`);\n        } catch (nameError) {\n          console.warn(\"Could not fetch NFT name:\", nameError);\n          setTitle(`NFT #${tokenId}`);\n        }\n\n\n          // Get tokenURI with comprehensive metadata support\n          let metadataUrl = await getTokenMetadataURL(\n            client,\n            getAddress(contractAddress) as Address,\n            tokenId\n          );\n\n          // Handle IPFS URLs using shared utility\n          metadataUrl = ipfsToHttp(metadataUrl);\n\n          // Fetch metadata with abort signal\n          const response = await fetch(metadataUrl, {\n            signal: abortController.signal\n          });\n          \n          if (!response.ok) {\n            throw new Error(`Failed to fetch metadata: ${response.status}`);\n          }\n          \n          const fetchedMetadata = await response.json();\n          console.log(\"NFT metadata:\", fetchedMetadata);\n          \n          // Store metadata in state\n          setMetadata(fetchedMetadata);\n\n          // Call onLoad callback if provided\n          if (onLoad) {\n            onLoad(fetchedMetadata);\n          }\n\n          // Get image URL from metadata\n          let nftImageUrl = fetchedMetadata.image || fetchedMetadata.image_url;\n\n          // Handle IPFS URLs for image using shared utility\n          if (nftImageUrl) {\n            nftImageUrl = ipfsToHttp(nftImageUrl);\n          }\n\n          if (nftImageUrl) {\n            setImageUrl(nftImageUrl);\n          } else {\n            // If no image URL found, use placeholder\n            setImageUrl(PLACEHOLDER_IMAGE);\n          }\n\n          // Check for animation URL (video content)\n          if (fetchedMetadata.animation_url) {\n            const animationUrl = ipfsToHttp(fetchedMetadata.animation_url);\n            setVideoUrl(animationUrl);\n            setIsVideo(true);\n          }\n      } catch (err) {\n        // Don't update state if request was aborted\n        if (err instanceof Error && err.name === \"AbortError\") {\n          console.log(\"NFT data fetch was cancelled\");\n          return;\n        }\n        \n        console.error(\"Error fetching NFT:\", err);\n        const error = err instanceof Error ? err : new Error(String(err));\n        setError(`Failed to load NFT data: ${error.message}`);\n        setImageUrl(PLACEHOLDER_IMAGE);\n\n        // Call onError callback if provided\n        if (onError) {\n          onError(error);\n        }\n      } finally {\n        // Only update loading state if this request wasn't aborted\n        if (!abortController.signal.aborted) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    fetchNFTData();\n    \n    // Cleanup function to abort request if component unmounts or deps change\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [\n    contractAddress,\n    tokenId,\n    network,\n    onLoad,\n    onError,\n  ]);\n\n  const defaultLoadingComponent = (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-300 dark:bg-gray-700\">\n      <div className=\"w-full h-full bg-gray-200 dark:bg-gray-800 animate-pulse\"></div>\n    </div>\n  );\n\n  const defaultErrorComponent = (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800\">\n      <p className=\"text-red-500 text-sm text-center px-2\">{error}</p>\n    </div>\n  );\n\n  // Render network badge inside the image\n  const renderNetworkBadge = () => {\n    if (!showNetwork || !networkName)\n      return null;\n\n    return (\n      <div\n        className={cn(\n          \"absolute bg-black/60 px-2 py-1 text-white text-xs\",\n          networkPositionClasses[\"top-right\"],\n        )}\n      >\n        {networkName}\n      </div>\n    );\n  };\n\n  // Render title inside the image\n  const renderInnerTitle = () => {\n    if (!showTitle || !title) return null;\n\n    return (\n      <div\n        className={cn(\n          \"absolute left-0 right-0 bg-black/60 p-2 text-white text-sm truncate\",\n          \"bottom-0\",\n        )}\n      >\n        {title}\n      </div>\n    );\n  };\n\n  // Render outside information (title, network)\n  const renderOutsideInfo = () => {\n    if (\n      (!showTitle || !title) &&\n      (!showNetwork || !networkName)\n    ) {\n      return null;\n    }\n\n    return (\n      <div className=\"mt-2\">\n        {showTitle && title && (\n          <div className={cn(\"text-sm font-medium truncate\")}>\n            {title}\n          </div>\n        )}\n\n        {showNetwork && networkName && (\n          <div\n            className={cn(\n              \"text-xs text-gray-500 dark:text-gray-400\",\n                )}\n          >\n            Network: {networkName}\n          </div>\n        )}\n\n      </div>\n    );\n  };\n\n  // Apply container classes\n  const getContainerClasses = () => {\n    return \"\";\n  };\n\n  // Calculate display dimensions that preserve aspect ratio\n  const getDisplayDimensions = () => {\n    // Handle percentage values\n    const isPercentageSize = typeof size === \"string\" && size.includes(\"%\");\n    \n    if (isPercentageSize) {\n      return { \n        width: size, \n        height: size, \n        useContain: false,\n        isPercentage: true\n      };\n    }\n    \n    const numericSize = typeof size === \"number\" ? size : 300;\n    \n    // Get dimensions from metadata or image natural dimensions\n    const dimensionsFromMetadata = metadata?.image_details?.width && metadata?.image_details?.height \n      ? { width: metadata.image_details.width, height: metadata.image_details.height }\n      : null;\n    \n    const availableDimensions = dimensionsFromMetadata || imageDimensions || videoDimensions;\n    \n    // If we have dimensions, calculate dynamic height based on aspect ratio\n    if (availableDimensions) {\n      const aspectRatio = availableDimensions.width / availableDimensions.height;\n      const dynamicHeight = Math.round(numericSize / aspectRatio);\n      \n      return { \n        width: numericSize, \n        height: dynamicHeight,\n        useContain: false, // No need for contain with dynamic sizing\n        isPercentage: false\n      };\n    }\n    \n    // No dimensions available, use square\n    return { width: numericSize, height: numericSize, useContain: false, isPercentage: false };\n  };\n\n  const displayDimensions = getDisplayDimensions();\n  \n  // Apply flexible aspect ratio for any media with known dimensions\n  const shouldUseFlexibleHeight = (isVideo && videoDimensions) || imageDimensions || (metadata?.image_details?.width && metadata?.image_details?.height);\n  \n  // Calculate container height - now using the dynamic height from getDisplayDimensions\n  const containerHeight = displayDimensions.isPercentage \n    ? displayDimensions.height \n    : `${displayDimensions.height}px`;\n\n  return (\n    <div className={cn(getContainerClasses())}>\n      <div\n        className={cn(\n          \"relative overflow-hidden\",\n          roundedClasses[rounded],\n          shadow && \"shadow-md\",\n          className,\n        )}\n        style={{ \n          width: displayDimensions.isPercentage \n            ? displayDimensions.width \n            : `${displayDimensions.width}px`, \n          height: containerHeight\n        }}\n      >\n        {isLoading && defaultLoadingComponent}\n\n        {error && defaultErrorComponent}\n\n        {videoUrl ? (\n          <>\n            {/* Background for letterboxing - only show if not using flexible aspect ratio */}\n            {!shouldUseFlexibleHeight && (\n              <div className=\"absolute inset-0 bg-black/5 dark:bg-white/5\" />\n            )}\n            <video\n              src={videoUrl}\n              poster={imageUrl}\n              autoPlay\n              loop\n              muted\n              playsInline\n              className={cn(\n                shouldUseFlexibleHeight ? \"w-full h-full\" : \"absolute inset-0 w-full h-full\",\n                !shouldUseFlexibleHeight && \"object-contain\",\n                isLoading && \"opacity-0\"\n              )}\n              style={{ \n                objectFit: shouldUseFlexibleHeight ? \"cover\" : \"contain\"\n              }}\n              onLoadedMetadata={(e) => {\n                const video = e.currentTarget;\n                setVideoDimensions({\n                  width: video.videoWidth,\n                  height: video.videoHeight\n                });\n              }}\n              onError={() => {\n                console.error(\"Video failed to load, falling back to image\");\n                setVideoUrl(null);\n              }}\n            />\n          </>\n        ) : (\n          <Image\n            src={imageUrl}\n            alt=\"NFT Image\"\n            fill={true}\n            className={cn(\n              shouldUseFlexibleHeight ? \"object-cover\" : \"object-contain\",\n              isLoading && \"opacity-0\"\n            )}\n            unoptimized={true}\n            onLoad={(e) => {\n              const img = e.currentTarget;\n              setImageDimensions({\n                width: img.naturalWidth,\n                height: img.naturalHeight\n              });\n            }}\n            onError={() => setImageUrl(PLACEHOLDER_IMAGE)}\n          />\n        )}\n\n        {renderInnerTitle()}\n        {renderNetworkBadge()}\n      </div>\n\n      {renderOutsideInfo()}\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/mini-app/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/chains.ts",
      "content": "import { http, type Chain, type PublicClient, createPublicClient } from \"viem\";\nimport * as chains from \"viem/chains\";\n\n/**\n * Supported chains configuration with Alchemy RPC support\n */\nexport const SUPPORTED_CHAINS = [\n  { id: 1, chain: chains.mainnet, alchemyPrefix: \"eth-mainnet\" },\n  { id: 8453, chain: chains.base, alchemyPrefix: \"base-mainnet\" },\n  { id: 42161, chain: chains.arbitrum, alchemyPrefix: \"arb-mainnet\" },\n  { id: 421614, chain: chains.arbitrumSepolia, alchemyPrefix: \"arb-sepolia\" },\n  { id: 84532, chain: chains.baseSepolia, alchemyPrefix: \"base-sepolia\" },\n  { id: 666666666, chain: chains.degen, alchemyPrefix: \"degen-mainnet\" },\n  { id: 100, chain: chains.gnosis, alchemyPrefix: \"gnosis-mainnet\" },\n  { id: 10, chain: chains.optimism, alchemyPrefix: \"opt-mainnet\" },\n  { id: 11155420, chain: chains.optimismSepolia, alchemyPrefix: \"opt-sepolia\" },\n  { id: 137, chain: chains.polygon, alchemyPrefix: \"polygon-mainnet\" },\n  { id: 11155111, chain: chains.sepolia, alchemyPrefix: \"eth-sepolia\" },\n  { id: 7777777, chain: chains.zora, alchemyPrefix: \"zora-mainnet\" },\n  { id: 130, chain: chains.ham, alchemyPrefix: \"unichain-mainnet\" }, // Unichain\n  {\n    id: 10143,\n    chain: {\n      id: 10143,\n      name: \"Monad Testnet\",\n      network: \"monad-testnet\",\n      nativeCurrency: { name: \"Monad\", symbol: \"MON\", decimals: 18 },\n      rpcUrls: {\n        default: { http: [\"https://testnet.monad.xyz\"] },\n        public: { http: [\"https://testnet.monad.xyz\"] },\n      },\n    } as const,\n    alchemyPrefix: null,\n  },\n  { id: 42220, chain: chains.celo, alchemyPrefix: \"celo-mainnet\" },\n] as const;\n\n/**\n * Get viem Chain object by ID\n */\nexport function getChainById(chainId: number): Chain {\n  const config = SUPPORTED_CHAINS.find((c) => c.id === chainId);\n  return config?.chain || chains.mainnet;\n}\n\n/**\n * Get HTTP transport with optional Alchemy RPC URL\n * Falls back to public RPC if no Alchemy key is available\n */\nexport function getTransport(chainId: number) {\n  const alchemyKey = process.env.NEXT_PUBLIC_ALCHEMY_KEY;\n  const config = SUPPORTED_CHAINS.find((c) => c.id === chainId);\n\n  if (config?.alchemyPrefix && alchemyKey) {\n    return http(\n      `https://${config.alchemyPrefix}.g.alchemy.com/v2/${alchemyKey}`,\n    );\n  }\n\n  // Fallback to default public RPC\n  return http();\n}\n\n/**\n * Create a public client for a specific chain with optimal transport\n */\nexport function getPublicClient(chainId: number): PublicClient {\n  return createPublicClient({\n    chain: getChainById(chainId),\n    transport: getTransport(chainId),\n  }) as PublicClient;\n}\n\n/**\n * Find chain by network name (case-insensitive)\n */\nexport function findChainByName(networkName: string): Chain | undefined {\n  const normalizedName = networkName.toLowerCase().trim();\n  \n  // Direct name mappings\n  const nameToId: Record<string, number> = {\n    ethereum: 1,\n    mainnet: 1,\n    base: 8453,\n    arbitrum: 42161,\n    \"arbitrum one\": 42161,\n    \"arbitrum sepolia\": 421614,\n    \"base sepolia\": 84532,\n    degen: 666666666,\n    gnosis: 100,\n    optimism: 10,\n    \"optimism sepolia\": 11155420,\n    polygon: 137,\n    sepolia: 11155111,\n    \"ethereum sepolia\": 11155111,\n    zora: 7777777,\n    unichain: 130,\n    ham: 130,\n    \"monad testnet\": 10143,\n    monad: 10143,\n    celo: 42220,\n  };\n  \n  const chainId = nameToId[normalizedName];\n  return chainId ? getChainById(chainId) : undefined;\n}\n\n/**\n * Get Alchemy RPC endpoint URL for a specific chain\n */\nexport function getAlchemyEndpoint(chainId: number, apiKey: string): string | undefined {\n  const config = SUPPORTED_CHAINS.find((c) => c.id === chainId);\n  \n  if (config?.alchemyPrefix && apiKey) {\n    return `https://${config.alchemyPrefix}.g.alchemy.com/v2/${apiKey}`;\n  }\n  \n  return undefined;\n}\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/nft-standards.ts",
      "content": "import { parseAbi, type Address } from \"viem\";\n\n/**\n * Common NFT contract ABIs and standards\n */\n\n// Standard ERC721 functions\nexport const ERC721_ABI = {\n  full: parseAbi([\n    \"function tokenURI(uint256 tokenId) view returns (string)\",\n    \"function name() view returns (string)\",\n    \"function symbol() view returns (string)\",\n    \"function ownerOf(uint256 tokenId) view returns (address)\",\n    \"function balanceOf(address owner) view returns (uint256)\",\n    \"function totalSupply() view returns (uint256)\",\n    \"function baseURI() view returns (string)\",\n    \"function contractURI() view returns (string)\",\n  ]),\n  \n  // Individual functions for specific use cases\n  tokenURI: parseAbi([\"function tokenURI(uint256 tokenId) view returns (string)\"]),\n  name: parseAbi([\"function name() view returns (string)\"]),\n  symbol: parseAbi([\"function symbol() view returns (string)\"]),\n  ownerOf: parseAbi([\"function ownerOf(uint256 tokenId) view returns (address)\"]),\n  baseURI: parseAbi([\"function baseURI() view returns (string)\"]),\n  contractURI: parseAbi([\"function contractURI() view returns (string)\"]),\n};\n\n// Common price discovery functions across NFT contracts\nexport const PRICE_DISCOVERY_ABI = parseAbi([\n  \"function mintPrice() view returns (uint256)\",\n  \"function price() view returns (uint256)\",\n  \"function MINT_PRICE() view returns (uint256)\",\n  \"function getMintPrice() view returns (uint256)\",\n  \"function publicMintPrice() view returns (uint256)\",\n]);\n\n// Common mint functions\nexport const MINT_ABI = parseAbi([\n  \"function mint(uint256 amount) payable\",\n  \"function mint(address to, uint256 amount) payable\",\n  \"function publicMint(uint256 amount) payable\",\n  \"function mintTo(address to, uint256 amount) payable\",\n]);\n\n// ERC1155 metadata function\nexport const ERC1155_ABI = {\n  uri: parseAbi([\"function uri(uint256 tokenId) view returns (string)\"]),\n};\n\n// ERC20 ABI for token interactions\nexport const ERC20_ABI = parseAbi([\n  \"function decimals() view returns (uint8)\",\n  \"function symbol() view returns (string)\",\n  \"function name() view returns (string)\",\n  \"function totalSupply() view returns (uint256)\",\n  \"function balanceOf(address owner) view returns (uint256)\",\n  \"function allowance(address owner, address spender) view returns (uint256)\",\n  \"function approve(address spender, uint256 value) returns (bool)\",\n  \"function transfer(address to, uint256 value) returns (bool)\",\n  \"function transferFrom(address from, address to, uint256 value) returns (bool)\",\n]);\n\n// Manifold contract detection ABI (kept separate as it's used on the main contract)\nexport const MANIFOLD_DETECTION_ABI = parseAbi([\n  \"function getExtensions() view returns (address[])\",\n]);\n\n// Manifold ERC721 extension contract ABI (includes contractVersion and identical fields)\nexport const MANIFOLD_ERC721_EXTENSION_ABI = [\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"tokenURI\",\n    outputs: [{ name: \"uri\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" }\n    ],\n    name: \"getClaim\",\n    outputs: [\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"identical\", type: \"uint8\" },\n          { name: \"merkleRootEmpty\", type: \"bool\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"getClaimForToken\",\n    outputs: [\n      { name: \"instanceId\", type: \"uint256\" },\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"identical\", type: \"uint8\" },\n          { name: \"merkleRootEmpty\", type: \"bool\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" },\n      { name: \"mintIndex\", type: \"uint32\" },\n      { name: \"merkleProof\", type: \"bytes32[]\" },\n      { name: \"mintFor\", type: \"address\" }\n    ],\n    name: \"mint\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE_MERKLE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n] as const;\n\n// Manifold ERC1155 extension contract ABI (13 fields - no contractVersion or identical)\nexport const MANIFOLD_ERC1155_EXTENSION_ABI = [\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"tokenURI\",\n    outputs: [{ name: \"uri\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" }\n    ],\n    name: \"getClaim\",\n    outputs: [\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"tokenId\", type: \"uint256\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"getClaimForToken\",\n    outputs: [\n      { name: \"instanceId\", type: \"uint256\" },\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"tokenId\", type: \"uint256\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" },\n      { name: \"mintIndex\", type: \"uint32\" },\n      { name: \"merkleProof\", type: \"bytes32[]\" },\n      { name: \"mintFor\", type: \"address\" }\n    ],\n    name: \"mint\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE_MERKLE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n] as const;\n\n// Backward compatibility - defaults to ERC721 version\nexport const MANIFOLD_EXTENSION_ABI = MANIFOLD_ERC721_EXTENSION_ABI;\n\n// ERC165 interface detection\nexport const ERC165_ABI = parseAbi([\n  \"function supportsInterface(bytes4 interfaceId) view returns (bool)\",\n]);\n\n// Known contract addresses\nexport const KNOWN_CONTRACTS = {\n  // Manifold extension contracts\n  manifoldExtension: \"0x26BBEA7803DcAc346D5F5f135b57Cf2c752A02bE\" as Address,\n  \n  // Add other known contracts here as needed\n} as const;\n\n// thirdweb OpenEditionERC721 ABI\nexport const THIRDWEB_OPENEDITONERC721_ABI = [\n  {\n    inputs: [\n      { name: \"_receiver\", type: \"address\" },\n      { name: \"_quantity\", type: \"uint256\" },\n      { name: \"_currency\", type: \"address\" },\n      { name: \"_pricePerToken\", type: \"uint256\" },\n      {\n        components: [\n          { name: \"proof\", type: \"bytes32[]\" },\n          { name: \"quantityLimitPerWallet\", type: \"uint256\" },\n          { name: \"pricePerToken\", type: \"uint256\" },\n          { name: \"currency\", type: \"address\" }\n        ],\n        name: \"_allowlistProof\",\n        type: \"tuple\"\n      },\n      { name: \"_data\", type: \"bytes\" }\n    ],\n    name: \"claim\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"claimCondition\",\n    outputs: [\n      { name: \"currentStartId\", type: \"uint256\" },\n      { name: \"count\", type: \"uint256\" }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ name: \"_conditionId\", type: \"uint256\" }],\n    name: \"getClaimConditionById\",\n    outputs: [\n      {\n        components: [\n          { name: \"startTimestamp\", type: \"uint256\" },\n          { name: \"maxClaimableSupply\", type: \"uint256\" },\n          { name: \"supplyClaimed\", type: \"uint256\" },\n          { name: \"quantityLimitPerWallet\", type: \"uint256\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"pricePerToken\", type: \"uint256\" },\n          { name: \"currency\", type: \"address\" },\n          { name: \"metadata\", type: \"string\" }\n        ],\n        name: \"condition\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"sharedMetadata\",\n    outputs: [\n      { name: \"name\", type: \"string\" },\n      { name: \"description\", type: \"string\" },\n      { name: \"image\", type: \"string\" },\n      { name: \"animationUrl\", type: \"string\" }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n] as const;\n\n// Native ETH address for thirdweb contracts\nexport const THIRDWEB_NATIVE_TOKEN = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" as Address;\n\n// Interface IDs for contract detection\nexport const INTERFACE_IDS = {\n  ERC165: \"0x01ffc9a7\",\n  ERC721: \"0x80ac58cd\",\n  ERC1155: \"0xd9b67a26\",\n  ERC721Metadata: \"0x5b5e139f\",\n} as const;\n\n// IPFS Gateway configuration\nexport const IPFS_GATEWAYS = {\n  default: \"https://ipfs.io/ipfs/\",\n  cloudflare: \"https://cloudflare-ipfs.com/ipfs/\",\n  pinata: \"https://gateway.pinata.cloud/ipfs/\",\n} as const;\n\n/**\n * Convert IPFS URL to HTTP gateway URL\n */\nexport function ipfsToHttp(url: string, gateway?: keyof typeof IPFS_GATEWAYS): string {\n  const selectedGateway = gateway || \"default\";\n  if (!url || !url.startsWith(\"ipfs://\")) {\n    return url;\n  }\n  \n  return url.replace(\"ipfs://\", IPFS_GATEWAYS[selectedGateway]);\n}\n\n/**\n * Check if a contract is likely an NFT contract by checking interface support\n */\nexport async function isNFTContract(\n  client: any,\n  contractAddress: Address\n): Promise<{ isNFT: boolean; type?: 'ERC721' | 'ERC1155' }> {\n  try {\n    // Try ERC165 supportsInterface\n    const [supportsERC721, supportsERC1155] = await Promise.all([\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC721],\n      }).catch(() => false),\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC1155],\n      }).catch(() => false),\n    ]);\n    \n    if (supportsERC721) return { isNFT: true, type: 'ERC721' };\n    if (supportsERC1155) return { isNFT: true, type: 'ERC1155' };\n    \n    // Fallback: try to call name() function\n    const name = await client.readContract({\n      address: contractAddress,\n      abi: ERC721_ABI.name,\n      functionName: 'name',\n    }).catch(() => null);\n    \n    return { isNFT: !!name };\n  } catch {\n    return { isNFT: false };\n  }\n}",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/nft-metadata-utils.ts",
      "content": "import { type Address, type PublicClient, getAddress } from \"viem\";\nimport { \n  MANIFOLD_DETECTION_ABI, \n  MANIFOLD_EXTENSION_ABI, \n  KNOWN_CONTRACTS, \n  ERC721_ABI,\n  ERC1155_ABI,\n  THIRDWEB_OPENEDITONERC721_ABI\n} from \"@/registry/mini-app/lib/nft-standards\";\n\n/**\n * NFT metadata utilities with support for multiple standards and fallback mechanisms\n */\n\nexport type ProviderHint = \"manifold\" | \"thirdweb\" | \"standard\" | \"erc1155\";\n\nexport interface ManifoldDetectionResult {\n  isManifold: boolean;\n  extensionAddress?: Address;\n  extensions?: Address[];\n}\n\nexport interface ManifoldClaim {\n  total: number;\n  totalMax: number;\n  walletMax: number;\n  startDate: bigint;\n  endDate: bigint;\n  storageProtocol: number;\n  merkleRoot: `0x${string}`;\n  location: string;\n  tokenId: bigint;\n  cost: bigint;\n  paymentReceiver: Address;\n  erc20: Address;\n  signingAddress: Address;\n}\n\n/**\n * Detect if a contract is a Manifold contract with extensions\n */\nexport async function detectManifoldContract(\n  client: PublicClient,\n  contractAddress: Address\n): Promise<ManifoldDetectionResult> {\n  try {\n    const extensions = await client.readContract({\n      address: getAddress(contractAddress),\n      abi: MANIFOLD_DETECTION_ABI,\n      functionName: \"getExtensions\",\n    }) as Address[];\n    \n    if (!extensions || extensions.length === 0) {\n      return { isManifold: false };\n    }\n    \n    // Check if it has the known Manifold extension\n    const knownExtension = extensions.find(\n      ext => ext.toLowerCase() === KNOWN_CONTRACTS.manifoldExtension.toLowerCase()\n    );\n    \n    return {\n      isManifold: true,\n      extensionAddress: knownExtension || extensions[0],\n      extensions,\n    };\n  } catch {\n    return { isManifold: false };\n  }\n}\n\n/**\n * Get token URI for a Manifold NFT\n */\nexport async function getManifoldTokenURI(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string,\n  extensionAddress?: Address\n): Promise<string> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  return await client.readContract({\n    address: getAddress(extension),\n    abi: MANIFOLD_EXTENSION_ABI,\n    functionName: \"tokenURI\",\n    args: [getAddress(contractAddress), BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get token URI with automatic Manifold detection\n * @deprecated Use getTokenMetadataURL instead for more comprehensive metadata support\n */\nexport async function getTokenURIWithManifoldSupport(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string\n): Promise<string> {\n  // Try Manifold first\n  const manifoldInfo = await detectManifoldContract(client, contractAddress);\n  \n  if (manifoldInfo.isManifold && manifoldInfo.extensionAddress) {\n    try {\n      return await getManifoldTokenURI(\n        client,\n        contractAddress,\n        tokenId,\n        manifoldInfo.extensionAddress\n      );\n    } catch (error) {\n      console.warn(\"Failed to get Manifold tokenURI, falling back to standard\", error);\n    }\n  }\n  \n  // Fallback to standard ERC721 tokenURI\n  return await client.readContract({\n    address: getAddress(contractAddress),\n    abi: ERC721_ABI.tokenURI,\n    functionName: \"tokenURI\",\n    args: [BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get token metadata URL with comprehensive fallback chain\n * Supports multiple NFT standards including ERC721, ERC1155, Manifold, and Thirdweb OpenEditions\n * \n * @param client - Public client for blockchain interactions\n * @param contractAddress - NFT contract address\n * @param tokenId - Token ID to fetch metadata for\n * @param providerHint - Optional hint about the contract type for optimization\n * @returns Token metadata URL or empty string if not found\n */\nexport async function getTokenMetadataURL(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string,\n  providerHint?: ProviderHint\n): Promise<string> {\n  const address = getAddress(contractAddress);\n  const tokenIdBigInt = BigInt(tokenId);\n  \n  // If provider hint is given, try that first\n  if (providerHint) {\n    try {\n      switch (providerHint) {\n        case \"manifold\": {\n          const manifoldInfo = await detectManifoldContract(client, address);\n          if (manifoldInfo.isManifold && manifoldInfo.extensionAddress) {\n            return await getManifoldTokenURI(client, address, tokenId, manifoldInfo.extensionAddress);\n          }\n          break;\n        }\n        case \"erc1155\": {\n          const uri = await client.readContract({\n            address,\n            abi: ERC1155_ABI.uri,\n            functionName: \"uri\",\n            args: [tokenIdBigInt],\n          }) as string;\n          // ERC1155 URIs often have {id} placeholder that needs to be replaced\n          return uri.replace(\"{id}\", tokenId.padStart(64, \"0\"));\n        }\n        case \"thirdweb\": {\n          // Try sharedMetadata first for OpenEditions\n          const metadata = await client.readContract({\n            address,\n            abi: THIRDWEB_OPENEDITONERC721_ABI,\n            functionName: \"sharedMetadata\",\n          }) as any;\n          if (metadata && metadata.image) {\n            // Construct metadata JSON from sharedMetadata\n            const metadataJson = {\n              name: metadata.name || \"\",\n              description: metadata.description || \"\",\n              image: metadata.image,\n              animation_url: metadata.animationUrl || undefined,\n            };\n            // Return as data URI\n            return `data:application/json;base64,${btoa(JSON.stringify(metadataJson))}`;\n          }\n          break;\n        }\n      }\n    } catch (error) {\n      console.debug(`Provider hint ${providerHint} failed, trying other methods`, error);\n    }\n  }\n  \n  // Comprehensive fallback chain\n  const fallbackMethods = [\n    // 1. Standard ERC721 tokenURI\n    async () => {\n      return await client.readContract({\n        address,\n        abi: ERC721_ABI.tokenURI,\n        functionName: \"tokenURI\",\n        args: [tokenIdBigInt],\n      }) as string;\n    },\n    \n    // 2. ERC1155 uri\n    async () => {\n      const uri = await client.readContract({\n        address,\n        abi: ERC1155_ABI.uri,\n        functionName: \"uri\",\n        args: [tokenIdBigInt],\n      }) as string;\n      // Replace {id} placeholder if present\n      return uri.replace(\"{id}\", tokenId.padStart(64, \"0\"));\n    },\n    \n    // 3. Manifold detection and tokenURI\n    async () => {\n      const manifoldInfo = await detectManifoldContract(client, address);\n      if (manifoldInfo.isManifold && manifoldInfo.extensionAddress) {\n        return await getManifoldTokenURI(client, address, tokenId, manifoldInfo.extensionAddress);\n      }\n      throw new Error(\"Not a Manifold contract\");\n    },\n    \n    // 4. contractURI (for contracts with shared metadata)\n    async () => {\n      const contractURI = await client.readContract({\n        address,\n        abi: ERC721_ABI.contractURI,\n        functionName: \"contractURI\",\n      }) as string;\n      // Note: contractURI typically contains collection-level metadata, not token-specific\n      // This is a last resort fallback\n      return contractURI;\n    },\n    \n    // 5. Thirdweb sharedMetadata (for OpenEditions)\n    async () => {\n      const metadata = await client.readContract({\n        address,\n        abi: THIRDWEB_OPENEDITONERC721_ABI,\n        functionName: \"sharedMetadata\",\n      }) as any;\n      \n      if (metadata && metadata.image) {\n        // Construct metadata JSON from sharedMetadata\n        const metadataJson = {\n          name: metadata.name || `Token #${tokenId}`,\n          description: metadata.description || \"\",\n          image: metadata.image,\n          animation_url: metadata.animationUrl || undefined,\n        };\n        // Return as data URI\n        return `data:application/json;base64,${btoa(JSON.stringify(metadataJson))}`;\n      }\n      throw new Error(\"No shared metadata found\");\n    },\n    \n    // 6. baseURI + tokenId concatenation\n    async () => {\n      const baseURI = await client.readContract({\n        address,\n        abi: ERC721_ABI.baseURI,\n        functionName: \"baseURI\",\n      }) as string;\n      \n      if (baseURI) {\n        // Ensure proper URL joining\n        const separator = baseURI.endsWith(\"/\") ? \"\" : \"/\";\n        return `${baseURI}${separator}${tokenId}`;\n      }\n      throw new Error(\"No baseURI found\");\n    },\n  ];\n  \n  // Try each method in order\n  for (const method of fallbackMethods) {\n    try {\n      const result = await method();\n      if (result && typeof result === \"string\" && result.length > 0) {\n        return result;\n      }\n    } catch (error) {\n      // Continue to next method\n      continue;\n    }\n  }\n  \n  // If all methods fail, return empty string\n  console.warn(`Could not fetch metadata for token ${tokenId} at ${contractAddress}`);\n  return \"\";\n}\n\n/**\n * Get Manifold claim information\n */\nexport async function getManifoldClaim(\n  client: PublicClient,\n  contractAddress: Address,\n  instanceId: string,\n  extensionAddress?: Address\n): Promise<ManifoldClaim | null> {\n  try {\n    const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n    \n    const claim = await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"getClaim\",\n      args: [getAddress(contractAddress), BigInt(instanceId)],\n    });\n    \n    return claim as unknown as ManifoldClaim;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get Manifold mint fee\n */\nexport async function getManifoldMintFee(\n  client: PublicClient,\n  extensionAddress?: Address\n): Promise<bigint> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  try {\n    return await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"MINT_FEE\",\n    }) as bigint;\n  } catch {\n    // Try MINT_FEE_MERKLE as fallback\n    try {\n      return await client.readContract({\n        address: getAddress(extension),\n        abi: MANIFOLD_EXTENSION_ABI,\n        functionName: \"MINT_FEE_MERKLE\",\n      }) as bigint;\n    } catch {\n      return BigInt(0);\n    }\n  }\n}\n\n/**\n * Check if an address is the zero address\n */\nexport function isZeroAddress(address: string): boolean {\n  return address === \"0x0000000000000000000000000000000000000000\";\n}\n\n/**\n * Format instance ID and token ID for display\n */\nexport function formatManifoldTokenId(instanceId: string, tokenId: string): string {\n  return `${instanceId}-${tokenId}`;\n}",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "meta": {
    "use_cases": [
      "NFT Showcase",
      "Digital Collectibles Display"
    ],
    "keywords": [
      "nft",
      "collectible",
      "mint"
    ]
  }
}